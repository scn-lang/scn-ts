uuid: 4f3640b8-c2b5-4a5f-a3f7-926f21c57c50
projectId: scn-ts
createdAt: '2025-07-30T03:03:44.683Z'
linesAdded: 26
linesRemoved: 28
gitCommitMsg: 'test: update tests to run against built artifacts'
promptSummary: >-
  The user wants to update the tests to import from the built `dist` directory
  instead of the `src` directory.
reasoning:
  - >-
    To fulfill your request, I'll modify the test files to import from the built
    `dist` directory instead of the `src` directory. This ensures that the tests
    are running against the production code.
  - '### Step 1: Update E2E CLI Tests'
  - >-
    First, I'll update the end-to-end tests for the CLI. I will change the path
    to the CLI executable from `src/cli.ts` to `dist/cli.js` and adjust the
    `Bun.spawn` calls to execute the JavaScript file directly instead of using
    `bun run`.
  - '### Step 2: Update Integration and Unit Test Imports'
  - >-
    Next, I'll update all integration and unit tests to import from
    `dist/index.js` instead of `src/index`.
  - >-
    These changes ensure all tests validate the compiled artifacts in the `dist`
    directory, providing a more accurate test of the distributable package.
operations:
  - type: write
    path: test/ts/e2e/cli.test.ts
    content: >-
      --- test/ts/e2e/cli.test.ts

      +++ test/ts/e2e/cli.test.ts

      @@ -3,10 +3,10 @@
       import { join, resolve } from 'path';
       import { version } from '../../../package.json';
       
      -// Path to the CLI script in the main workspace

      -const CLI_PATH = resolve(process.cwd(), 'src/cli.ts');

      +const CLI_PATH = resolve(process.cwd(), 'dist/cli.js');
       
       describe('SCN Generation: 3. Command-Line Interface (CLI)', () => {
         let project: TestProject | undefined;
      @@ -23,7 +23,7 @@
             'b.ts': 'export const B = 2;',
           });
           
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH, 'a.ts'], {

      +    const proc = Bun.spawn(['bun', CLI_PATH, 'a.ts'], {
             cwd: project.projectDir,
             stderr: 'pipe',
             stdout: 'pipe',
      @@ -42,7 +42,7 @@
           project = await setupTestProject({ 'a.ts': 'export const A = 1;' });
           const outputPath = join(project.projectDir, 'output.scn');
       
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH, 'a.ts', '--output',
      outputPath], {

      +    const proc = Bun.spawn(['bun', CLI_PATH, 'a.ts', '--output',
      outputPath], {
             cwd: project.projectDir,
           });
           
      @@ -56,7 +56,7 @@
             'tsconfig.test.json': JSON.stringify({ compilerOptions: { jsx: 'react-jsx' } }),
           });
       
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH, 'Comp.tsx', '-p',
      'tsconfig.test.json'], {

      +    const proc = Bun.spawn(['bun', CLI_PATH, 'Comp.tsx', '-p',
      'tsconfig.test.json'], {
             cwd: project.projectDir,
           });
           
      @@ -66,13 +66,13 @@
         });
       
         it('should display the correct version with --version', async () => {
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH, '--version']);

      +    const proc = Bun.spawn(['bun', CLI_PATH, '--version']);
           const stdout = await new Response(proc.stdout).text();
           expect(stdout.trim()).toBe(version);
         });
         
         it('should display the help screen with --help', async () => {
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH, '--help']);

      +    const proc = Bun.spawn(['bun', CLI_PATH, '--help']);
           const stdout = await new Response(proc.stdout).text();
           expect(stdout).toContain('Usage:');
           expect(stdout).toContain('--output <path>');
      @@ -82,7 +82,7 @@
           project = await setupTestProject({}); // Empty project
           
           // Test with no input files specified - this should trigger the error
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH], {

      +    const proc = Bun.spawn(['bun', CLI_PATH], {
             cwd: project.projectDir,
             stderr: 'pipe',
             stdout: 'pipe',
    patchStrategy: new-unified
  - type: write
    path: test/ts/e2e/config-file.test.ts
    content: >-
      --- test/ts/e2e/config-file.test.ts

      +++ test/ts/e2e/config-file.test.ts

      @@ -2,10 +2,10 @@
       import { setupTestProject, type TestProject } from '../../test.util';
       import { readFile } from 'fs/promises';
       import { join, resolve } from 'path';
       
       // Path to the CLI script in the main workspace
      -const CLI_PATH = resolve(process.cwd(), 'src/cli.ts');

      +const CLI_PATH = resolve(process.cwd(), 'dist/cli.js');
       
       describe('SCN Generation: 4. Configuration (scn.config.js)', () => {
         let project: TestProject | undefined;
      @@ -22,7 +22,7 @@
             'scn.config.js': `export default { include: ['a.ts'] };`,
           });
           
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH], { 

      +    const proc = Bun.spawn(['bun', CLI_PATH], { 
             cwd: project.projectDir,
             stderr: 'pipe',
             stdout: 'pipe',
      @@ -41,7 +41,7 @@
             'scn.config.js': `export default { include: ['**/*.ts'], exclude: ['**/*.ignore.ts'] };`,
           });
           
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH], { 

      +    const proc = Bun.spawn(['bun', CLI_PATH], { 
             cwd: project.projectDir,
             stderr: 'pipe',
             stdout: 'pipe',
      @@ -60,7 +60,7 @@
             'scn.config.js': `import {mkdirSync} from 'fs'; mkdirSync('dist'); export default { include: ['a.ts'], output: '${outputPath}' };`,
           });
           
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH], { 

      +    const proc = Bun.spawn(['bun', CLI_PATH], { 
             cwd: project.projectDir,
             stderr: 'pipe',
             stdout: 'pipe',
      @@ -82,7 +82,7 @@
           });
           
           // Override both `include` and `output`
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH, 'b.ts', '-o',
      cliOutputPath], {

      +    const proc = Bun.spawn(['bun', CLI_PATH, 'b.ts', '-o',
      cliOutputPath], {
             cwd: project.projectDir,
             stderr: 'pipe',
             stdout: 'pipe',
      @@ -104,7 +104,7 @@
             'config/my.config.js': `export default { include: ['a.ts'] };`,
           });
           
      -    const proc = Bun.spawn(['bun', 'run', CLI_PATH, '-c',
      'config/my.config.js'], { 

      +    const proc = Bun.spawn(['bun', CLI_PATH, '-c',
      'config/my.config.js'], { 
             cwd: project.projectDir,
             stderr: 'pipe',
             stdout: 'pipe',
    patchStrategy: new-unified
  - type: write
    path: test/ts/e2e/filesystem.test.ts
    content: >-
      --- test/ts/e2e/filesystem.test.ts

      +++ test/ts/e2e/filesystem.test.ts

      @@ -3,8 +3,8 @@
       import { readFile, writeFile, rm } from 'fs/promises';
       import { join, resolve } from 'path';
       
      -// Path to the CLI script in the main workspace

      -const CLI_PATH = resolve(process.cwd(), 'src/cli.ts');

      +const CLI_PATH = resolve(process.cwd(), 'dist/cli.js');
       
       // Helper to wait for a file to contain specific content
       async function waitForFileContent(filePath: string, expectedContent: string, timeout = 5000): Promise<void> {
      @@ -38,7 +38,7 @@
           });
           const outputPath = join(project.projectDir, 'output.scn');
       
      -    watcherProc = Bun.spawn(['bun', 'run', CLI_PATH, '--watch', '-o',
      outputPath, '**/*.ts'], {

      +    watcherProc = Bun.spawn(['bun', CLI_PATH, '--watch', '-o',
      outputPath, '**/*.ts'], {
             cwd: project.projectDir,
           });
       
      @@ -59,7 +59,7 @@
           });
           const outputPath = join(project.projectDir, 'output.scn');
       
      -    watcherProc = Bun.spawn(['bun', 'run', CLI_PATH, '--watch', '-o',
      outputPath, '**/*.ts'], {

      +    watcherProc = Bun.spawn(['bun', CLI_PATH, '--watch', '-o',
      outputPath, '**/*.ts'], {
             cwd: project.projectDir,
           });
           
      @@ -81,7 +81,7 @@
           const outputPath = join(project.projectDir, 'output.scn');
           const fileToDelete = join(project.projectDir, 'b.ts');
       
      -    watcherProc = Bun.spawn(['bun', 'run', CLI_PATH, '--watch', '-o',
      outputPath, '**/*.ts'], {

      +    watcherProc = Bun.spawn(['bun', CLI_PATH, '--watch', '-o',
      outputPath, '**/*.ts'], {
             cwd: project.projectDir,
           });
       
      @@ -109,7 +109,7 @@
           const outputPath = join(project.projectDir, 'output with spaces.scn');
           
           const proc = Bun.spawn(
      -      ['bun', 'run', CLI_PATH, 'my component.ts', '-o', 'output with
      spaces.scn'],

      +      ['bun', CLI_PATH, 'my component.ts', '-o', 'output with
      spaces.scn'],
             { cwd: project.projectDir }
           );
           await proc.exited;
    patchStrategy: new-unified
  - type: write
    path: test/ts/integration/css-parsing.test.ts
    content: |-
      <<<<<<< SEARCH
      import { generateScn } from '../../../src/index';
      =======
      import { generateScn } from '../../../dist/index.js';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/ts/integration/dependency-graph.test.ts
    content: |-
      <<<<<<< SEARCH
      import { generateScn } from '../../../src/index';
      =======
      import { generateScn } from '../../../dist/index.js';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/ts/integration/programmatic-api.test.ts
    content: |-
      <<<<<<< SEARCH
        type CodeEdge as RepographEdge,
      } from '../../../src/index';
      import { setupTestProject, type TestProject } from '../../test.util';
      =======
        type CodeEdge as RepographEdge,
      } from '../../../dist/index.js';
      import { setupTestProject, type TestProject } from '../../test.util';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/ts/unit/code-entities.test.ts
    content: |-
      <<<<<<< SEARCH
      import { generateScn } from '../../../src/index';
      =======
      import { generateScn } from '../../../dist/index.js';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/ts/unit/general-structural.test.ts
    content: |-
      <<<<<<< SEARCH
      import { generateScn } from '../../../src/index';
      =======
      import { generateScn } from '../../../dist/index.js';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/ts/unit/jsx.test.ts
    content: |-
      <<<<<<< SEARCH
      import { generateScn } from '../../../src/index';
      =======
      import { generateScn } from '../../../dist/index.js';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/ts/unit/qualifiers.test.ts
    content: |-
      <<<<<<< SEARCH
      import { generateScn } from '../../../src/index';
      =======
      import { generateScn } from '../../../dist/index.js';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/ts/unit/type-system.test.ts
    content: |-
      <<<<<<< SEARCH
      import { generateScn } from '../../../src/index';
      =======
      import { generateScn } from '../../../dist/index.js';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  test/ts/e2e/cli.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { setupTestProject, type TestProject } from '../../test.util';
    import { readFile } from 'fs/promises';
    import { join, resolve } from 'path';
    import { version } from '../../../package.json';

    // Path to the CLI script in the main workspace
    const CLI_PATH = resolve(process.cwd(), 'src/cli.ts');

    describe('SCN Generation: 3. Command-Line Interface (CLI)', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('should process glob patterns provided as arguments and print to stdout', async () => {
        project = await setupTestProject({
          'a.ts': 'export const A = 1;',
          'b.ts': 'export const B = 2;',
        });
        
        const proc = Bun.spawn(['bun', 'run', CLI_PATH, 'a.ts'], {
          cwd: project.projectDir,
          stderr: 'pipe',
          stdout: 'pipe',
        });

        const stdout = await new Response(proc.stdout).text();
        const stderr = await new Response(proc.stderr).text();
        await proc.exited;
        const exitCode = proc.exitCode;

        expect(exitCode).toBe(0);
        expect(stdout).toContain('§ (1) a.ts');
        expect(stdout).not.toContain('b.ts');
        expect(stderr).toContain('[SCN-TS] Analyzing project...');
      });
      
      it('should write the output to the file specified by --output', async () => {
        project = await setupTestProject({ 'a.ts': 'export const A = 1;' });
        const outputPath = join(project.projectDir, 'output.scn');

        const proc = Bun.spawn(['bun', 'run', CLI_PATH, 'a.ts', '--output', outputPath], {
          cwd: project.projectDir,
        });
        
        await proc.exited;
        
        const outputContent = await readFile(outputPath, 'utf-8');
        expect(outputContent).toContain('§ (1) a.ts');
      });

      it('should respect the tsconfig file specified by --project', async () => {
        project = await setupTestProject({
          'Comp.tsx': 'export const C = () => <div />',
          'tsconfig.test.json': JSON.stringify({ compilerOptions: { jsx: 'react-jsx' } }),
        });

        const proc = Bun.spawn(['bun', 'run', CLI_PATH, 'Comp.tsx', '-p', 'tsconfig.test.json'], {
          cwd: project.projectDir,
        });
        
        const stdout = await new Response(proc.stdout).text();
        await proc.exited;
        expect(proc.exitCode).toBe(0);
        expect(stdout).toContain('◇ (1.1) C');
      });

      it('should display the correct version with --version', async () => {
        const proc = Bun.spawn(['bun', 'run', CLI_PATH, '--version']);
        const stdout = await new Response(proc.stdout).text();
        expect(stdout.trim()).toBe(version);
      });
      
      it('should display the help screen with --help', async () => {
        const proc = Bun.spawn(['bun', 'run', CLI_PATH, '--help']);
        const stdout = await new Response(proc.stdout).text();
        expect(stdout).toContain('Usage:');
        expect(stdout).toContain('--output <path>');
      });
      
      it('should exit with a non-zero code on error', async () => {
        project = await setupTestProject({}); // Empty project
        
        // Test with no input files specified - this should trigger the error
        const proc = Bun.spawn(['bun', 'run', CLI_PATH], {
          cwd: project.projectDir,
          stderr: 'pipe',
          stdout: 'pipe',
        });

        const stderr = await new Response(proc.stderr).text();
        await proc.exited;
        const exitCode = proc.exitCode;
        
        expect(exitCode).not.toBe(0);
        expect(stderr).toContain('Error: No input files specified');
      });
    });
  test/ts/e2e/config-file.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { setupTestProject, type TestProject } from '../../test.util';
    import { readFile } from 'fs/promises';
    import { join, resolve } from 'path';

    // Path to the CLI script in the main workspace
    const CLI_PATH = resolve(process.cwd(), 'src/cli.ts');

    describe('SCN Generation: 4. Configuration (scn.config.js)', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });
      
      it('should automatically find and load scn.config.js from the project root', async () => {
        project = await setupTestProject({
          'a.ts': 'const a = 1;',
          'b.ts': 'const b = 2;',
          'scn.config.js': `export default { include: ['a.ts'] };`,
        });
        
        const proc = Bun.spawn(['bun', 'run', CLI_PATH], { 
          cwd: project.projectDir,
          stderr: 'pipe',
          stdout: 'pipe',
        });
        const stdout = await new Response(proc.stdout).text();
        await proc.exited;
        
        expect(proc.exitCode).toBe(0);
        expect(stdout).toContain('§ (1) a.ts');
        expect(stdout).not.toContain('b.ts');
      });
      
      it('should correctly apply `exclude` patterns from the config', async () => {
        project = await setupTestProject({
          'a.ts': 'const a = 1;',
          'b.ignore.ts': 'const b = 2;',
          'scn.config.js': `export default { include: ['**/*.ts'], exclude: ['**/*.ignore.ts'] };`,
        });
        
        const proc = Bun.spawn(['bun', 'run', CLI_PATH], { 
          cwd: project.projectDir,
          stderr: 'pipe',
          stdout: 'pipe',
        });
        const stdout = await new Response(proc.stdout).text();
        await proc.exited;
        
        expect(proc.exitCode).toBe(0);
        expect(stdout).toContain('§ (1) a.ts');
        expect(stdout).not.toContain('b.ignore.ts');
      });

      it('should write to the `output` path specified in the config', async () => {
        const outputPath = 'dist/output.scn';
        project = await setupTestProject({
          'a.ts': 'const a = 1;',
          'scn.config.js': `import {mkdirSync} from 'fs'; mkdirSync('dist'); export default { include: ['a.ts'], output: '${outputPath}' };`,
        });
        
        const proc = Bun.spawn(['bun', 'run', CLI_PATH], { 
          cwd: project.projectDir,
          stderr: 'pipe',
          stdout: 'pipe',
        });
        await proc.exited;

        expect(proc.exitCode).toBe(0);
        const outputContent = await readFile(join(project.projectDir, outputPath), 'utf-8');
        expect(outputContent).toContain('§ (1) a.ts');
      });

      it('should override config file settings with CLI flags', async () => {
        const configOutputPath = 'config-output.scn';
        const cliOutputPath = 'cli-output.scn';
        
        project = await setupTestProject({
          'a.ts': 'const a = 1;',
          'b.ts': 'const b = 2;',
          'scn.config.js': `export default { include: ['a.ts'], output: '${configOutputPath}' };`,
        });
        
        // Override both `include` and `output`
        const proc = Bun.spawn(['bun', 'run', CLI_PATH, 'b.ts', '-o', cliOutputPath], {
          cwd: project.projectDir,
          stderr: 'pipe',
          stdout: 'pipe',
        });
        await proc.exited;

        expect(proc.exitCode).toBe(0);

        // Check that the CLI output path was used and has the correct content
        const cliOutputContent = await readFile(join(project.projectDir, cliOutputPath), 'utf-8');
        expect(cliOutputContent).toContain('§ (1) b.ts');
        expect(cliOutputContent).not.toContain('a.ts');

        // Check that the config output path was NOT created
        await expect(readFile(join(project.projectDir, configOutputPath), 'utf-8')).rejects.toThrow();
      });

      it('should respect the config file specified by --config or -c', async () => {
        project = await setupTestProject({
          'a.ts': 'const a = 1;',
          'config/my.config.js': `export default { include: ['a.ts'] };`,
        });
        
        const proc = Bun.spawn(['bun', 'run', CLI_PATH, '-c', 'config/my.config.js'], { 
          cwd: project.projectDir,
          stderr: 'pipe',
          stdout: 'pipe',
        });
        const stdout = await new Response(proc.stdout).text();
        await proc.exited;
        
        expect(proc.exitCode).toBe(0);
        expect(stdout).toContain('§ (1) a.ts');
      });
    });
  test/ts/e2e/filesystem.test.ts: >-
    import { describe, it, expect, afterEach } from 'bun:test';

    import { setupTestProject, type TestProject } from '../../test.util';

    import { readFile, writeFile, rm } from 'fs/promises';

    import { join, resolve } from 'path';


    // Path to the CLI script in the main workspace

    const CLI_PATH = resolve(process.cwd(), 'src/cli.ts');


    // Helper to wait for a file to contain specific content

    async function waitForFileContent(filePath: string, expectedContent: string,
    timeout = 5000): Promise<void> {
      const start = Date.now();
      while (Date.now() - start < timeout) {
        try {
          const content = await readFile(filePath, 'utf-8');
          if (content.includes(expectedContent)) {
            return;
          }
        } catch {
          // File might not exist yet
        }
        await new Promise(resolve => setTimeout(resolve, 100)); // Poll every 100ms
      }
      throw new Error(`Timeout waiting for "${expectedContent}" in ${filePath}`);
    }


    describe('SCN Generation: 5. File System & Watch Mode', () => {
      let project: TestProject | undefined;
      let watcherProc: ReturnType<typeof Bun.spawn> | undefined;

      afterEach(async () => {
        if (watcherProc) {
          watcherProc.kill();
          watcherProc = undefined;
        }
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('--watch: should perform an initial scan and re-generate when a file is modified', async () => {
        project = await setupTestProject({
          'a.ts': 'export const A = 1;',
        });
        const outputPath = join(project.projectDir, 'output.scn');

        watcherProc = Bun.spawn(['bun', 'run', CLI_PATH, '--watch', '-o', outputPath, '**/*.ts'], {
          cwd: project.projectDir,
        });

        // 1. Wait for initial generation
        await waitForFileContent(outputPath, 'A = 1');
        const initialContent = await readFile(outputPath, 'utf-8');
        expect(initialContent).toContain('§ (1) a.ts');
        expect(initialContent).toContain('◇ (1.1) A = 1');
        
        // 2. Modify the file
        await writeFile(join(project.projectDir, 'a.ts'), 'export const A = 42;');

        // 3. Wait for re-generation
        await waitForFileContent(outputPath, 'A = 42');
        const updatedContent = await readFile(outputPath, 'utf-8');
        expect(updatedContent).toContain('◇ (1.1) A = 42');
      });

      it('--watch: should re-generate when a new file matching the glob is added', async () => {
        project = await setupTestProject({
          'a.ts': 'export const A = 1;',
        });
        const outputPath = join(project.projectDir, 'output.scn');

        watcherProc = Bun.spawn(['bun', 'run', CLI_PATH, '--watch', '-o', outputPath, '**/*.ts'], {
          cwd: project.projectDir,
        });
        
        // 1. Wait for initial generation
        await waitForFileContent(outputPath, 'a.ts');
        
        // 2. Add a new file
        await writeFile(join(project.projectDir, 'b.ts'), 'export const B = 2;');

        // 3. Wait for re-generation to include the new file
        await waitForFileContent(outputPath, 'b.ts');
        const updatedContent = await readFile(outputPath, 'utf-8');
        expect(updatedContent).toContain('§ (1) a.ts');
        expect(updatedContent).toContain('§ (2) b.ts');
      });

      it('--watch: should re-generate when a tracked file is deleted', async () => {
        project = await setupTestProject({
          'a.ts': 'export const A = 1;',
          'b.ts': 'export const B = 2;',
        });
        const outputPath = join(project.projectDir, 'output.scn');
        const fileToDelete = join(project.projectDir, 'b.ts');

        watcherProc = Bun.spawn(['bun', 'run', CLI_PATH, '--watch', '-o', outputPath, '**/*.ts'], {
          cwd: project.projectDir,
        });

        // 1. Wait for initial generation
        await waitForFileContent(outputPath, 'b.ts');
        const initialContent = await readFile(outputPath, 'utf-8');
        expect(initialContent).toContain('b.ts');

        // 2. Delete the file
        await rm(fileToDelete);

        // 3. Wait for re-generation (b.ts should be gone)
        const start = Date.now();
        let contentHasB = true;
        while(contentHasB && Date.now() - start < 5000) {
            const content = await readFile(outputPath, 'utf-8');
            if (!content.includes('b.ts')) {
                contentHasB = false;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        expect(contentHasB).toBe(false);
        const updatedContent = await readFile(outputPath, 'utf-8');
        expect(updatedContent).toContain('a.ts');
        expect(updatedContent).not.toContain('b.ts');
      });

      it('should handle file paths with spaces correctly', async () => {
         project = await setupTestProject({
          'my component.ts': 'export const MyComponent = 1;',
        });
        const outputPath = join(project.projectDir, 'output with spaces.scn');
        
        const proc = Bun.spawn(
          ['bun', 'run', CLI_PATH, 'my component.ts', '-o', 'output with spaces.scn'],
          { cwd: project.projectDir }
        );
        await proc.exited;

        expect(proc.exitCode).toBe(0);
        const outputContent = await readFile(outputPath, 'utf-8');
        expect(outputContent).toContain('§ (1) "my component.ts"');
      });
    });
  test/ts/integration/css-parsing.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { generateScn } from '../../../src/index';
    import { setupTestProject, type TestProject } from '../../test.util';

    describe('SCN Generation: 1.7 CSS Parsing & Integration', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('should generate a ¶ CSS Rule for each selector and include intent symbols', async () => {
        project = await setupTestProject({
          'styles.css': `
            .layout-only {
              display: flex;
              position: absolute;
            }
            .text-only {
              font-weight: bold;
              text-align: center;
            }
            .appearance-only {
              background-color: blue;
              border: 1px solid red;
            }
            .all-intents {
              padding: 8px; /* layout */
              font-size: 16px; /* text */
              color: white; /* appearance */
            }
          `,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.css'] });
        
        // The order of intent symbols is sorted alphabetically by the serializer.
        expect(scn).toContain('  ¶ (1.1) .layout-only { 📐 }');
        expect(scn).toContain('  ¶ (1.2) .text-only { ✍ }');
        expect(scn).toContain('  ¶ (1.3) .appearance-only { 💧 }');
        expect(scn).toContain('  ¶ (1.4) .all-intents { 💧 📐 ✍ }');
      });

      it('should create links between a JSX element and CSS rules via className', async () => {
        project = await setupTestProject({
          'Button.css': `
            .btn { color: white; }
            .btn-primary { background-color: blue; }
          `,
          'Button.tsx': `
            import './Button.css';
            export function Button() {
              return <button className="btn btn-primary">Click</button>;
            }
          `,
          // tsconfig needed for repograph to process jsx/css imports
          'tsconfig.json': JSON.stringify({
            "compilerOptions": { "jsx": "react-jsx", "allowJs": true },
            "include": ["**/*.ts", "**/*.tsx"]
          }),
        });
        
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.{ts,tsx,css}'], project: 'tsconfig.json' });

        // File sorting is alphabetical: Button.css -> 1, Button.tsx -> 2
        const tsxScn = scn.split('\n\n').find(s => s.includes('Button.tsx'));
        const cssScn = scn.split('\n\n').find(s => s.includes('Button.css'));

        expect(cssScn).toBeDefined();
        expect(tsxScn).toBeDefined();

        // Check file-level links (import relationship)
        expect(tsxScn!).toContain('§ (2) Button.tsx\n  -> (1.0)');
        expect(cssScn!).toContain('§ (1) Button.css\n  <- (2.0)');

        // Check entity-level links
        // ⛶ button (2.2) should link to both .btn (1.1) and .btn-primary (1.2)
        expect(tsxScn!).toContain('    ⛶ (2.2) button [ class:.btn .btn-primary ]\n      -> (1.1), (1.2)');
        
        // ¶ .btn (1.1) should link back to ⛶ button (2.2)
        expect(cssScn!).toContain('  ¶ (1.1) .btn { 💧 }\n    <- (2.2)');
        
        // ¶ .btn-primary (1.2) should link back to ⛶ button (2.2)
        expect(cssScn!).toContain('  ¶ (1.2) .btn-primary { 💧 }\n    <- (2.2)');
      });

      it('should create links between a JSX element and a CSS rule via id', async () => {
        project = await setupTestProject({
          'App.css': `
            #main-container { border: 1px solid black; }
          `,
          'App.tsx': `
            import './App.css';
            export function App() {
              return <div id="main-container">...</div>;
            }
          `,
          'tsconfig.json': JSON.stringify({
            "compilerOptions": { "jsx": "react-jsx", "allowJs": true },
            "include": ["**/*.ts", "**/*.tsx"]
          }),
        });
        
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.{ts,tsx,css}'], project: 'tsconfig.json' });
        
        // File sorting is alphabetical: App.css -> 1, App.tsx -> 2
        const tsxScn = scn.split('\n\n').find(s => s.includes('App.tsx'));
        const cssScn = scn.split('\n\n').find(s => s.includes('App.css'));

        expect(cssScn).toBeDefined();
        expect(tsxScn).toBeDefined();

        // Check entity-level links
        // ⛶ div (2.2) should link to #main-container (1.1)
        expect(tsxScn!).toContain('    ⛶ (2.2) div [ id:#main-container ]\n      -> (1.1)');
        // ¶ #main-container (1.1) should link back to ⛶ div (2.2)
        expect(cssScn!).toContain('  ¶ (1.1) #main-container { 💧 }\n    <- (2.2)');
      });
    });
  test/ts/integration/dependency-graph.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { generateScn } from '../../../src/index';
    import { setupTestProject, type TestProject } from '../../test.util';

    describe('SCN Generation: 1.2 Inter-File Dependency Graphs', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('should resolve and add <- annotations to entities that are used by other entities', async () => {
        project = await setupTestProject({
          'util.ts': `export function helper() {}`,
          'main.ts': `import { helper } from './util'; function main() { helper(); }`,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });

        const utilScn = scn.split('\n\n').find(s => s.includes('util.ts'));
        expect(utilScn).toBeDefined();
        // main.ts is file 1, util.ts is file 2.
        // main.ts's 'main' (1.1) calls util.ts's 'helper' (2.1)
        expect(utilScn).toContain('§ (2) util.ts\n  <- (1.0)');
        expect(utilScn).toContain('  + ~ (2.1) helper()\n    <- (1.1)');
      });

      it('should add a summary of file-level dependencies and callers on the § file declaration line', async () => {
        project = await setupTestProject({
          'config.ts': `export const setting = 1;`,
          'service.ts': `import { setting } from './config'; export const value = setting;`,
          'main.ts': `import { value } from './service'; console.log(value);`,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });

        // Files are sorted alphabetically: config.ts (1), main.ts (2), service.ts (3)
        // main.ts imports service.ts. service.ts imports config.ts
        expect(scn).toContain('§ (1) config.ts\n  <- (3.0)');
        expect(scn).toContain('§ (2) main.ts\n  -> (3.0)');
        expect(scn).toContain('§ (3) service.ts\n  -> (1.0)\n  <- (2.0)');
      });

      it('should correctly represent a multi-step dependency chain (A -> B -> C)', async () => {
        project = await setupTestProject({
          'c.ts': `export const C = 'c';`,
          'b.ts': `import { C } from './c'; export const B = C;`,
          'a.ts': `import { B } from './b'; function run() { console.log(B); }`,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });

        // File-level links. a.ts (1), b.ts (2), c.ts (3)
        expect(scn).toContain('§ (1) a.ts\n  -> (2.0)');
        expect(scn).toContain('§ (2) b.ts\n  -> (3.0)\n  <- (1.0)');
        expect(scn).toContain('§ (3) c.ts\n  <- (2.0)');

        // Entity-level links
        const aScn = scn.split('\n\n').find(s => s.includes('a.ts'));
        const bScn = scn.split('\n\n').find(s => s.includes('b.ts'));
        const cScn = scn.split('\n\n').find(s => s.includes('c.ts'));

        expect(aScn).toContain('  ~ (1.1) run()\n    -> (2.1)'); // run() in a.ts uses B from b.ts
        expect(bScn).toContain('  + ◇ (2.1) B = C\n    -> (3.1)\n    <- (1.1)'); // B in b.ts uses C from c.ts and is used by run() from a.ts
        expect(cScn).toContain('  + ◇ (3.1) C = \'c\'\n    <- (2.1)'); // C is used by B
      });
      
      it('should link a dependency from the function that uses it, not just the file', async () => {
        project = await setupTestProject({
          'util.ts': `export function log() {}`,
          'main.ts': `
            import { log } from './util';
            function run() {
              log();
            }
          `,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });

        const mainScn = scn.split('\n\n').find(s => s.includes('main.ts'));
        expect(mainScn).toBeDefined();
        expect(mainScn).toContain('§ (1) main.ts\n  -> (2.0)');
        expect(mainScn).toContain('  ~ (1.1) run()\n    -> (2.1)');
      });

      it('should support linking to multiple entities on one line', async () => {
         project = await setupTestProject({
          'util.ts': `
            export function helperA() {}
            export function helperB() {}
          `,
          'main.ts': `
            import { helperA, helperB } from './util';
            export function run() {
              helperA();
              helperB();
            }
          `,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        const mainScn = scn.split('\n\n').find(s => s.includes('main.ts'));
        expect(mainScn).toBeDefined();
        // main.ts is file 1, util.ts is file 2.
        // run is 1.1, helperA is 2.1, helperB is 2.2
        expect(mainScn).toContain('§ (1) main.ts\n  -> (2.0)');
        expect(mainScn).toContain('  + ~ (1.1) run()\n    -> (2.1), (2.2)');
      });
    });
  test/ts/integration/programmatic-api.test.ts: >-
    import { describe, it, expect, afterEach } from 'bun:test';

    import {
      generateScn,
      serializeGraph,
      type RankedCodeGraph,
      type CodeNode,
      type CodeEdge as RepographEdge,
    } from '../../../src/index';

    import { setupTestProject, type TestProject } from '../../test.util';

    import { rm } from 'fs/promises';

    import { tmpdir } from 'os';

    import { join } from 'path';


    // Re-define the extended edge type used internally by the serializer

    type CodeEdge = Omit<RepographEdge, 'type'> & { type: RepographEdge['type']
    | 'contains' | 'references' };


    describe('SCN Generation: 2. Programmatic API', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });
      
      describe('2.1 High-Level API (generateScn)', () => {
        it('should generate a valid SCN string given a set of include globs', async () => {
          project = await setupTestProject({
            'a.ts': `export const A = 1;`,
            'b.ts': `export const B = 2;`,
          });

          const scn = await generateScn({ root: project.projectDir, include: ['a.ts'] });
          expect(scn).toContain('§ (1) a.ts');
          expect(scn).not.toContain('b.ts');
        });

        it('should respect exclude patterns', async () => {
          project = await setupTestProject({
            'a.ts': `export const A = 1;`,
            'b.ignore.ts': `export const B = 2;`,
          });

          const scn = await generateScn({
            root: project.projectDir,
            include: ['**/*.ts'],
            exclude: ['**/*.ignore.ts'],
          });
          expect(scn).toContain('§ (1) a.ts');
          expect(scn).not.toContain('b.ignore.ts');
        });

        it('should use the project tsconfig path for better type analysis', async () => {
          project = await setupTestProject({
            'Button.tsx': `export const Button = () => <button>Click</button>;`,
            'tsconfig.json': JSON.stringify({
                "compilerOptions": { "jsx": "react-jsx" },
            }),
          });

          const scn = await generateScn({
            root: project.projectDir,
            include: ['**/*.tsx'],
            project: 'tsconfig.json',
          });
          
          // Correct parsing of JSX depends on tsconfig.json
          expect(scn).toContain('§ (1) Button.tsx');
          expect(scn).toContain('+ ◇ (1.2) Button');
          expect(scn).toContain('⛶ (1.3) button');
        });

        it('should return an empty string for globs that match no files', async () => {
          project = await setupTestProject({
            'a.ts': `export const A = 1;`,
          });
          const scn = await generateScn({ root: project.projectDir, include: ['**/*.js'] });
          expect(scn).toBe('');
        });

        it('should throw an error for non-existent root directory', async () => {
            const nonExistentDir = join(tmpdir(), 'scn-ts-non-existent-dir-test');
            await rm(nonExistentDir, { recursive: true, force: true }).catch(() => {});
            
            const promise = generateScn({ root: nonExistentDir, include: ['**/*.ts'] });
            
            // repograph is expected to throw when the root path does not exist.
            await expect(promise).rejects.toThrow();
        });
      });

      describe('2.2 Low-Level API (serializeGraph)', () => {
        it('should serialize a resolved graph into spec-compliant SCN string', () => {
            const fileNodeA: CodeNode = { id: 'file-a', filePath: 'a.ts', type: 'file', name: 'a.ts', startLine: 1, endLine: 1, codeSnippet: '', };
            const funcNodeA: CodeNode = { id: 'func-a', filePath: 'a.ts', type: 'function', name: 'funcA', visibility: 'public', startLine: 2, endLine: 2, codeSnippet: 'function funcA()', };
            const fileNodeB: CodeNode = { id: 'file-b', filePath: 'b.ts', type: 'file', name: 'b.ts', startLine: 1, endLine: 1, codeSnippet: '', };
            const funcNodeB: CodeNode = { id: 'func-b', filePath: 'b.ts', type: 'function', name: 'funcB', visibility: 'public', startLine: 2, endLine: 2, codeSnippet: 'function funcB()', };

            const nodes = new Map<string, CodeNode>([
                [fileNodeA.id, fileNodeA],
                [funcNodeA.id, funcNodeA],
                [fileNodeB.id, fileNodeB],
                [funcNodeB.id, funcNodeB],
            ]);
            
            const edges: CodeEdge[] = [
                // File A imports File B
                { fromId: 'file-a', toId: 'file-b', type: 'imports' },
                // funcA calls funcB
                { fromId: 'func-a', toId: 'func-b', type: 'references' },
            ];

            const ranks = new Map<string, number>([
                [fileNodeA.id, 0],
                [funcNodeA.id, 0],
                [fileNodeB.id, 0],
                [funcNodeB.id, 0],
            ]);
            const graph: RankedCodeGraph = { nodes, edges: edges as any, ranks };

            const scnOutput = serializeGraph(graph);
            
            const expectedScn = [
                '§ (1) a.ts\n  -> (2.0)\n  + ~ (1.1) funcA()\n    -> (2.1)',
                '§ (2) b.ts\n  <- (1.0)\n  + ~ (2.1) funcB()\n    <- (1.1)'
            ].join('\n\n');
            
            expect(scnOutput).toBe(expectedScn);
        });
      });
    });
  test/ts/unit/code-entities.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { generateScn } from '../../../src/index';
    import { setupTestProject, type TestProject } from '../../test.util';

    describe('SCN Generation: 1.3 Code Entities', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('should represent a class with ◇', async () => {
        project = await setupTestProject({ 'test.ts': `export class MyClass {}` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain('  + ◇ (1.1) MyClass');
      });

      it('should represent a namespace with ◇', async () => {
        project = await setupTestProject({ 'test.ts': `export namespace MyNamespace {}` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain('  + ◇ (1.1) MyNamespace');
      });

      it('should represent an exported uppercase object literal (module pattern) with ◇', async () => {
        project = await setupTestProject({ 'test.ts': `export const MyModule = { key: 'value' };` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain(`  + ◇ (1.1) MyModule { key: 'value' }`);
      });

      it('should represent an interface with {}', async () => {
        project = await setupTestProject({ 'test.ts': `export interface MyInterface {}` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain('  + {} (1.1) MyInterface');
      });

      it('should represent an export function with + ~', async () => {
        project = await setupTestProject({ 'test.ts': `export function myFunc() {}` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain('  + ~ (1.1) myFunc()');
      });

      it('should represent a const arrow function with ~', async () => {
        project = await setupTestProject({ 'test.ts': `const myFunc = () => {}` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain('  ~ (1.1) myFunc()');
      });

      it('should represent a class method with ~ and a property with @', async () => {
        project = await setupTestProject({
          'test.ts': `
          export class MyClass {
            myProp: string = '';
            myMethod() {}
          }`,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain('    + @ (1.2) myProp');
        expect(scn).toContain('    + ~ (1.3) myMethod()');
      });

      it('should represent a top-level const with @', async () => {
        project = await setupTestProject({ 'test.ts': `const myVar = 123;` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        // Note: repograph represents this as a "variable" and heuristic makes it not a container
        expect(scn).toContain('  @ (1.1) myVar = 123');
      });

      it('should correctly handle export default class', async () => {
        project = await setupTestProject({ 'test.ts': `export default class MyClass {}` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain('  + ◇ (1.1) MyClass');
      });

      it('should correctly handle export default function', async () => {
        project = await setupTestProject({ 'test.ts': `export default function myFunc() {}` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain('  + ~ (1.1) myFunc()');
      });

      it('should correctly handle export default anonymous function', async () => {
        project = await setupTestProject({ 'test.ts': `export default () => {}` });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });
        expect(scn).toContain('  + ~ (1.1) default()'); // repograph names it 'default'
      });
    });
  test/ts/unit/general-structural.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { generateScn } from '../../../src/index';
    import { setupTestProject, type TestProject } from '../../test.util';

    describe('SCN Generation: 1.1 General & Structural', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('should generate a § file declaration with a unique ID and correct relative path', async () => {
        project = await setupTestProject({
          'a.ts': ``,
          'b.ts': ``,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });

        expect(scn).toContain('§ (1) a.ts');
        expect(scn).toContain('§ (2) b.ts');
      });

      it('should assign unique, incrementing entity IDs within a file, starting from 1', async () => {
        project = await setupTestProject({
          'test.ts': `
            export function funcA() {}
            export class ClassB {}
          `,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });

        expect(scn).toContain('+ ~ (1.1) funcA()');
        expect(scn).toContain('+ ◇ (1.2) ClassB');
      });

      it('should represent a side-effect import with a .0 entity ID', async () => {
        project = await setupTestProject({
          'a.ts': `import './b.ts';`,
          'b.ts': `console.log('side effect');`,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });

        expect(scn).toContain('§ (1) a.ts\n  -> (2.0)');
        expect(scn).toContain('§ (2) b.ts\n  <- (1.0)');
      });

      it('should represent hierarchical code structures with correct indentation', async () => {
        project = await setupTestProject({
          'test.ts': `
            export namespace MyNamespace {
              export class MyClass {
                public myMethod() {}
              }
            }
          `,
        });
        const scn = await generateScn({
          root: project.projectDir,
          include: [`**/*.ts`],
        });

        const expected = [
          '  + ◇ (1.1) MyNamespace',
          '    + ◇ (1.2) MyClass',
          '      + ~ (1.3) myMethod()'
        ].join('\n');
        expect(scn).toContain(expected);
      });
    });
  test/ts/unit/jsx.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { generateScn } from '../../../src/index';
    import { setupTestProject, type TestProject } from '../../test.util';

    describe('SCN Generation: 1.6 JS/TS Specifics (JSX & Modules)', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('should correctly parse a React functional component with props with ◇', async () => {
        project = await setupTestProject({
          'Button.tsx': `
            export function Button({ label, onClick }: { label: string, onClick: () => void }) {
              return <button>{label}</button>
            }
          `,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.tsx'], project: 'tsconfig.json' });
        expect(scn).toContain('+ ◇ (1.1) Button { props: { label:#, onClick:# } }');
      });
      
      it('should represent a JSX element with ⛶ and its attributes', async () => {
        project = await setupTestProject({
          'Component.tsx': `
            export function Component() {
              return <div id="main" className="container fluid">Hello</div>;
            }
          `,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.tsx'], project: 'tsconfig.json' });
        const divLine = scn.split('\n').find(line => line.includes('⛶ (1.2) div'));
        expect(divLine).toBeDefined();
        expect(divLine!).toContain('id:#main');
        expect(divLine!).toContain('class:.container .fluid');
      });

      it('should represent JSX hierarchy with indentation', async () => {
        project = await setupTestProject({
          'App.tsx': `
            export function App() {
              return (
                <main>
                  <h1>Title</h1>
                </main>
              );
            }
          `,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.tsx'], project: 'tsconfig.json' });
        const lines = scn.split('\n');
        const mainIndex = lines.findIndex(l => l.includes('⛶ (1.2) main'));
        const h1Index = lines.findIndex(l => l.includes('⛶ (1.3) h1'));

        expect(mainIndex).toBeGreaterThan(-1);
        expect(h1Index).toBeGreaterThan(-1);
        expect(h1Index).toBe(mainIndex + 1);
        
        const mainIndentation = lines[mainIndex]!.match(/^\s*/)?.[0].length ?? 0;
        const h1Indentation = lines[h1Index]!.match(/^\s*/)?.[0].length ?? 0;
        
        expect(h1Indentation).toBeGreaterThan(mainIndentation);
      });

      it('should correctly parse various export syntaxes, including re-exports and aliases', async () => {
        project = await setupTestProject({
          'mod.ts': `
            const internal = 1;
            function b() {}
            export { internal as exported, b };
            export * from './another';
          `,
          'another.ts': 'export const c = 3;',
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        const modScn = scn.split('\n\n').find(s => s.includes('mod.ts'));
        // Files: another.ts (1), mod.ts (2)
        expect(modScn).toContain('§ (2) mod.ts\n  -> (1.0)');
        expect(modScn).toContain('@ (2.1) internal = 1');
        expect(modScn).toContain('~ (2.2) b()');
        // Note: The alias `exported` is not represented as a separate SCN entity.
        // The link is to the original `internal` variable.
      });

      it('should correctly parse various import syntaxes and link them from the consuming function', async () => {
        project = await setupTestProject({
          'util.ts': `
            export const val = 1;
            export function func() {}
            export default class MyClass {}
          `,
          'main.ts': `
            import MyClass, { val } from './util';
            import * as utils from './util';
            
            function run() {
                const x = val;
                utils.func();
                new MyClass();
            }
          `
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        const mainScn = scn.split('\n\n').find(s => s.includes('main.ts'));
        // Files: main.ts (1), util.ts (2)
        // Entities in util.ts: val (2.1), func (2.2), MyClass (2.3)
        // Entity in main.ts: run (1.1)
        expect(mainScn).toContain('§ (1) main.ts\n  -> (2.0)');
        expect(mainScn).toContain('  ~ (1.1) run()\n    -> (2.1), (2.2), (2.3)');
      });
    });
  test/ts/unit/qualifiers.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { generateScn } from '../../../src/index';
    import { setupTestProject, type TestProject } from '../../test.util';

    describe('SCN Generation: 1.5 Function & Method Qualifiers', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('should prefix public members with +', async () => {
        project = await setupTestProject({
          'test.ts': `export class MyClass { public myMethod() {} }`,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('+ ~ (1.2) myMethod()');
      });

      it('should prefix private members with -', async () => {
        project = await setupTestProject({
          'test.ts': `export class MyClass { private myMethod() {} }`,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('- ~ (1.2) myMethod()');
      });

      it('should treat default class members as public and prefix with +', async () => {
        project = await setupTestProject({
          'test.ts': `export class MyClass { myMethod() {} }`,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('+ ~ (1.2) myMethod()');
      });

      it('should append ... to an async function or method', async () => {
        project = await setupTestProject({
          'test.ts': `
            export async function myFunc() {}
            export class MyClass { async myMethod() {} }
          `,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('+ ~ (1.1) myFunc() ...');
        expect(scn).toContain('+ ~ (1.3) myMethod() ...');
      });

      it('should append ! to a function that has a throw statement', async () => {
        project = await setupTestProject({
          'test.ts': `export function myFunc() { throw new Error('test'); }`,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('+ ~ (1.1) myFunc() !');
      });

      it('should correctly handle functions that are both async and can throw', async () => {
        project = await setupTestProject({
          'test.ts': `export async function myFunc() { throw new Error('test'); }`,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('+ ~ (1.1) myFunc() ... !');
      });
      
      it('should append o to a pure function (repograph heuristic)', async () => {
        // This test relies on repograph's isPure heuristic.
        // A simple function with no side effects is a good candidate.
         project = await setupTestProject({
          'test.ts': `export function add(a: number, b: number): number { return a + b; }`,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('+ ~ (1.1) add(a: #, b: #): #number o');
      });
    });
  test/ts/unit/type-system.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { generateScn } from '../../../src/index';
    import { setupTestProject, type TestProject } from '../../test.util';

    describe('SCN Generation: 1.4 Type System Symbols', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('should represent an enum with ☰', async () => {
        project = await setupTestProject({ 'test.ts': `export enum Color { Red, Green }` });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('+ ☰ (1.1) Color');
      });

      it('should represent a type alias with =:', async () => {
        project = await setupTestProject({ 'test.ts': `export type UserID = string;` });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('+ =: (1.1) UserID = string');
      });

      it('should represent type references in function parameters with #', async () => {
        project = await setupTestProject({ 'test.ts': `function process(id: string, value: number) {}` });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('~ (1.1) process(id: #, value: #)');
      });
      
      it('should represent a function return type with :#Type', async () => {
        project = await setupTestProject({ 'test.ts': `function isActive(): boolean {}` });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('~ (1.1) isActive(): #boolean');
      });
      
      it('should correctly represent complex types like Promise<User>', async () => {
        project = await setupTestProject({ 'test.ts': `
          interface User {}
          function getUser(): Promise<User> { return Promise.resolve({} as User); }
        `});
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('~ (1.2) getUser(): #Promise<User>');
      });

      it('should correctly represent generic type parameters and return types', async () => {
        project = await setupTestProject({ 'test.ts': `
          function transform<T, U>(data: T[], func: (item: T) => U): U[] { return []; }
        `});
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        expect(scn).toContain('~ (1.1) transform(data: #, func: #): #U[]');
      });
    });
approved: true
