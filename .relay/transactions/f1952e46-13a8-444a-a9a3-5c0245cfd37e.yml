uuid: f1952e46-13a8-444a-a9a3-5c0245cfd37e
projectId: scn-ts
createdAt: '2025-07-22T01:55:26.586Z'
linesAdded: 508
linesRemoved: 1
gitCommitMsg: 'feat: implement cli, config, and watch mode features with e2e tests'
promptSummary: >-
  Implement tests for sections 3, 4, and 5 of the test plan, covering CLI,
  config files, and watch mode.
reasoning:
  - >-
    I will now implement the tests and required source code for sections 3, 4,
    and 5 of the test plan, which cover the Command-Line Interface (CLI),
    configuration files, and file system interactions including watch mode.
  - >-
    First, I will create the CLI entry point file, `src/cli.ts`. This file will
    be responsible for parsing command-line arguments, loading configuration,
    calling the core `generateScn` function, and handling behaviors like
    `--watch`, `--help`, and file output.
  - >-
    To support the CLI, I'll update `package.json` to include a version number
    and a `bin` entry, making it behave like a real command-line tool.
  - >-
    To correctly handle file paths that contain spaces, I will modify the
    serializer to quote such paths, adhering to best practices for file path
    representation.
  - >-
    Now, I will create the e2e test files to verify the CLI functionality.
    First, `cli.test.ts` for basic command-line operations.
  - >-
    Next, `config-file.test.ts` will verify that `scn.config.js` is loaded and
    that its options are correctly applied and overridden by CLI flags.
  - >-
    Finally, `filesystem.test.ts` will test watch mode and the handling of file
    paths with special characters.
operations:
  - type: write
    path: src/cli.ts
    content: >-
      import { generateScn, type ScnTsConfig } from './index.js';

      import { existsSync, readFileSync, watch } from 'fs';

      import { writeFile } from 'fs/promises';

      import { resolve, join, relative } from 'path';

      import { version } from '../package.json';


      interface CliOptions {
        include: string[];
        output?: string;
        project?: string;
        config?: string;
        watch: boolean;
        help: boolean;
        version: boolean;
      }


      function parseArgs(args: string[]): CliOptions {
        const options: CliOptions = {
          include: [],
          watch: false,
          help: false,
          version: false,
        };
        const cliArgs = args.slice(2);

        for (let i = 0; i < cliArgs.length; i++) {
          const arg = cliArgs[i];
          if (arg.startsWith('-')) {
            switch (arg) {
              case '-o':
              case '--output':
                options.output = cliArgs[++i];
                break;
              case '-p':
              case '--project':
                options.project = cliArgs[++i];
                break;
              case '-c':
              case '--config':
                options.config = cliArgs[++i];
                break;
              case '--watch':
                options.watch = true;
                break;
              case '-h':
              case '--help':
                options.help = true;
                break;
              case '-v':
              case '--version':
                options.version = true;
                break;
              default:
                console.error(`Unknown option: ${arg}`);
                process.exit(1);
            }
          } else {
            options.include.push(arg);
          }
        }

        return options;
      }


      async function loadConfig(configPath?: string):
      Promise<Partial<ScnTsConfig> & { output?: string }> {
        const path = resolve(process.cwd(), configPath || 'scn.config.js');
        if (existsSync(path)) {
          try {
            if (path.endsWith('.js')) {
              const configModule = await import(path);
              return configModule.default || configModule;
            }
            if (path.endsWith('.json')) {
               return JSON.parse(readFileSync(path, 'utf-8'));
            }
          } catch (e) {
            console.error(`Error loading config file: ${path}`);
            console.error(e);
            process.exit(1);
          }
        }
        return {};
      }


      function showHelp() {
        console.log(`
        scn-ts v${version}
        
        Generates a Symbolic Context Notation map from a TypeScript/JavaScript project.

        Usage:
          scn-ts [globs...] [options]

        Arguments:
          globs...         Glob patterns specifying files to include.

        Options:
          -o, --output <path>    Path to write the SCN output file. (default: stdout)
          -p, --project <path>   Path to tsconfig.json.
          -c, --config <path>    Path to a config file. (default: scn.config.js)
          --watch                Watch files for changes and re-generate.
          -v, --version          Display version number.
          -h, --help             Display this help message.
        `);
      }


      async function run() {
        const cliOptions = parseArgs(process.argv);

        if (cliOptions.version) {
          console.log(version);
          return;
        }
        
        if (cliOptions.help) {
          showHelp();
          return;
        }

        const fileConfig = await loadConfig(cliOptions.config);

        const config: ScnTsConfig = {
          root: process.cwd(),
          include: cliOptions.include.length > 0 ? cliOptions.include : (fileConfig.include || []),
          exclude: fileConfig.exclude,
          project: cliOptions.project || fileConfig.project,
        };
        
        const output = cliOptions.output || fileConfig.output;

        if (config.include.length === 0) {
          console.error('Error: No input files specified. Provide glob patterns as arguments or in a config file.');
          showHelp();
          process.exit(1);
        }

        const executeGeneration = async () => {
          try {
            console.error(`[SCN-TS] Analyzing project...`);
            const scn = await generateScn(config);
            if (output) {
              await writeFile(output, scn, 'utf-8');
              console.error(`[SCN-TS] SCN map written to ${relative(process.cwd(), output)}`);
            } else {
              console.log(scn);
            }
          } catch (e: any) {
            console.error(`[SCN-TS] Error during generation: ${e.message}`);
            if (!cliOptions.watch) {
               process.exit(1);
            }
          }
        };

        await executeGeneration();
        
        if (cliOptions.watch) {
          console.error('[SCN-TS] Watching for file changes...');
          watch(config.root || process.cwd(), { recursive: true }, async (eventType, filename) => {
              if (filename) {
                  console.error(`[SCN-TS] Change detected in '${filename}'. Re-generating...`);
                  await executeGeneration();
              }
          });
        }
      }


      run().catch(e => {
          console.error(e);
          process.exit(1);
      });
    patchStrategy: replace
  - type: write
    path: package.json
    content: |-
      <<<<<<< SEARCH
      {
        "name": "scn-ts",
        "module": "src/index.ts",
        "type": "module",
        "private": true,
        "devDependencies": {
      =======
      {
        "version": "1.0.0",
        "name": "scn-ts",
        "module": "src/index.ts",
        "bin": {
          "scn-ts": "src/cli.ts"
        },
        "type": "module",
        "private": true,
        "devDependencies": {
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/serializer.ts
    content: |-
      <<<<<<< SEARCH
      let header = `ยง (${scnId}) ${fileNode.filePath}`;
      =======
        const formattedPath = fileNode.filePath.includes(' ') ? `"${fileNode.filePath}"` : fileNode.filePath;
        let header = `ยง (${scnId}) ${formattedPath}`;
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/ts/e2e/cli.test.ts
    content: |-
      import { describe, it, expect, afterEach } from 'bun:test';
      import { setupTestProject, type TestProject } from '../../test.util';
      import { readFile } from 'fs/promises';
      import { join } from 'path';
      import { version } from '../../../package.json';

      describe('SCN Generation: 3. Command-Line Interface (CLI)', () => {
        let project: TestProject | undefined;

        afterEach(async () => {
          if (project) {
            await project.cleanup();
            project = undefined;
          }
        });

        it('should process glob patterns provided as arguments and print to stdout', async () => {
          project = await setupTestProject({
            'a.ts': 'export const A = 1;',
            'b.ts': 'export const B = 2;',
          });
          
          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts', 'a.ts'], {
            cwd: project.projectDir,
          });

          const stdout = await new Response(proc.stdout).text();
          const stderr = await new Response(proc.stderr).text();
          const exitCode = await proc.exitCode;

          expect(exitCode).toBe(0);
          expect(stdout).toContain('ยง (1) a.ts');
          expect(stdout).not.toContain('b.ts');
          expect(stderr).toContain('[SCN-TS] Analyzing project...');
        });
        
        it('should write the output to the file specified by --output', async () => {
          project = await setupTestProject({ 'a.ts': 'export const A = 1;' });
          const outputPath = join(project.projectDir, 'output.scn');

          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts', 'a.ts', '--output', outputPath], {
            cwd: project.projectDir,
          });
          
          await proc.exited;
          
          const outputContent = await readFile(outputPath, 'utf-8');
          expect(outputContent).toContain('ยง (1) a.ts');
        });

        it('should respect the tsconfig file specified by --project', async () => {
          project = await setupTestProject({
            'Comp.tsx': 'export const C = () => <div />',
            'tsconfig.test.json': JSON.stringify({ compilerOptions: { jsx: 'react-jsx' } }),
          });

          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts', 'Comp.tsx', '-p', 'tsconfig.test.json'], {
            cwd: project.projectDir,
          });
          
          const stdout = await new Response(proc.stdout).text();
          expect(await proc.exitCode).toBe(0);
          expect(stdout).toContain('โถ (1.2) div');
        });

        it('should display the correct version with --version', async () => {
          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts', '--version']);
          const stdout = await new Response(proc.stdout).text();
          expect(stdout.trim()).toBe(version);
        });
        
        it('should display the help screen with --help', async () => {
          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts', '--help']);
          const stdout = await new Response(proc.stdout).text();
          expect(stdout).toContain('Usage:');
          expect(stdout).toContain('--output <path>');
        });
        
        it('should exit with a non-zero code on error', async () => {
          project = await setupTestProject({}); // Empty project
          
          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts', 'nonexistent.ts'], {
            cwd: project.projectDir,
          });

          const stderr = await new Response(proc.stderr).text();
          const exitCode = await proc.exitCode;
          
          expect(exitCode).not.toBe(0);
          expect(stderr).toContain('Error');
        });
      });
    patchStrategy: replace
  - type: write
    path: test/ts/e2e/config-file.test.ts
    content: |-
      import { describe, it, expect, afterEach } from 'bun:test';
      import { setupTestProject, type TestProject } from '../../test.util';
      import { readFile } from 'fs/promises';
      import { join } from 'path';

      describe('SCN Generation: 4. Configuration (scn.config.js)', () => {
        let project: TestProject | undefined;

        afterEach(async () => {
          if (project) {
            await project.cleanup();
            project = undefined;
          }
        });
        
        it('should automatically find and load scn.config.js from the project root', async () => {
          project = await setupTestProject({
            'a.ts': 'const a = 1;',
            'b.ts': 'const b = 2;',
            'scn.config.js': `export default { include: ['a.ts'] };`,
          });
          
          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts'], { cwd: project.projectDir });
          const stdout = await new Response(proc.stdout).text();
          
          expect(await proc.exitCode).toBe(0);
          expect(stdout).toContain('ยง (1) a.ts');
          expect(stdout).not.toContain('b.ts');
        });
        
        it('should correctly apply `exclude` patterns from the config', async () => {
          project = await setupTestProject({
            'a.ts': 'const a = 1;',
            'b.ignore.ts': 'const b = 2;',
            'scn.config.js': `export default { include: ['**/*.ts'], exclude: ['**/*.ignore.ts'] };`,
          });
          
          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts'], { cwd: project.projectDir });
          const stdout = await new Response(proc.stdout).text();
          
          expect(await proc.exitCode).toBe(0);
          expect(stdout).toContain('ยง (1) a.ts');
          expect(stdout).not.toContain('b.ignore.ts');
        });

        it('should write to the `output` path specified in the config', async () => {
          const outputPath = 'dist/output.scn';
          project = await setupTestProject({
            'a.ts': 'const a = 1;',
            'scn.config.js': `import {mkdirSync} from 'fs'; mkdirSync('dist'); export default { include: ['a.ts'], output: '${outputPath}' };`,
          });
          
          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts'], { cwd: project.projectDir });
          await proc.exited;

          expect(await proc.exitCode).toBe(0);
          const outputContent = await readFile(join(project.projectDir, outputPath), 'utf-8');
          expect(outputContent).toContain('ยง (1) a.ts');
        });

        it('should override config file settings with CLI flags', async () => {
          const configOutputPath = 'config-output.scn';
          const cliOutputPath = 'cli-output.scn';
          
          project = await setupTestProject({
            'a.ts': 'const a = 1;',
            'b.ts': 'const b = 2;',
            'scn.config.js': `export default { include: ['a.ts'], output: '${configOutputPath}' };`,
          });
          
          // Override both `include` and `output`
          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts', 'b.ts', '-o', cliOutputPath], {
            cwd: project.projectDir,
          });
          await proc.exited;

          expect(await proc.exitCode).toBe(0);

          // Check that the CLI output path was used and has the correct content
          const cliOutputContent = await readFile(join(project.projectDir, cliOutputPath), 'utf-8');
          expect(cliOutputContent).toContain('ยง (1) b.ts');
          expect(cliOutputContent).not.toContain('a.ts');

          // Check that the config output path was NOT created
          await expect(readFile(join(project.projectDir, configOutputPath), 'utf-8')).rejects.toThrow();
        });

        it('should respect the config file specified by --config or -c', async () => {
          project = await setupTestProject({
            'a.ts': 'const a = 1;',
            'config/my.config.js': `export default { include: ['a.ts'] };`,
          });
          
          const proc = Bun.spawn(['bun', 'run', 'src/cli.ts', '-c', 'config/my.config.js'], { cwd: project.projectDir });
          const stdout = await new Response(proc.stdout).text();
          
          expect(await proc.exitCode).toBe(0);
          expect(stdout).toContain('ยง (1) a.ts');
        });
      });
    patchStrategy: replace
  - type: write
    path: test/ts/e2e/filesystem.test.ts
    content: >-
      import { describe, it, expect, afterEach } from 'bun:test';

      import { setupTestProject, type TestProject } from '../../test.util';

      import { readFile, writeFile, rm } from 'fs/promises';

      import { join } from 'path';


      // Helper to wait for a file to contain specific content

      async function waitForFileContent(filePath: string, expectedContent:
      string, timeout = 5000): Promise<void> {
        const start = Date.now();
        while (Date.now() - start < timeout) {
          try {
            const content = await readFile(filePath, 'utf-8');
            if (content.includes(expectedContent)) {
              return;
            }
          } catch {
            // File might not exist yet
          }
          await new Promise(resolve => setTimeout(resolve, 100)); // Poll every 100ms
        }
        throw new Error(`Timeout waiting for "${expectedContent}" in ${filePath}`);
      }


      describe('SCN Generation: 5. File System & Watch Mode', () => {
        let project: TestProject | undefined;
        let watcherProc: ReturnType<typeof Bun.spawn> | undefined;

        afterEach(async () => {
          if (watcherProc) {
            watcherProc.kill();
            watcherProc = undefined;
          }
          if (project) {
            await project.cleanup();
            project = undefined;
          }
        });

        it('--watch: should perform an initial scan and re-generate when a file is modified', async () => {
          project = await setupTestProject({
            'a.ts': 'export const A = 1;',
          });
          const outputPath = join(project.projectDir, 'output.scn');

          watcherProc = Bun.spawn(['bun', 'run', 'src/cli.ts', '--watch', '-o', outputPath, '**/*.ts'], {
            cwd: project.projectDir,
          });

          // 1. Wait for initial generation
          await waitForFileContent(outputPath, 'A = 1');
          const initialContent = await readFile(outputPath, 'utf-8');
          expect(initialContent).toContain('ยง (1) a.ts');
          expect(initialContent).toContain('@ (1.1) A = 1');
          
          // 2. Modify the file
          await writeFile(join(project.projectDir, 'a.ts'), 'export const A = 42;');

          // 3. Wait for re-generation
          await waitForFileContent(outputPath, 'A = 42');
          const updatedContent = await readFile(outputPath, 'utf-8');
          expect(updatedContent).toContain('@ (1.1) A = 42');
        });

        it('--watch: should re-generate when a new file matching the glob is added', async () => {
          project = await setupTestProject({
            'a.ts': 'export const A = 1;',
          });
          const outputPath = join(project.projectDir, 'output.scn');

          watcherProc = Bun.spawn(['bun', 'run', 'src/cli.ts', '--watch', '-o', outputPath, '**/*.ts'], {
            cwd: project.projectDir,
          });
          
          // 1. Wait for initial generation
          await waitForFileContent(outputPath, 'a.ts');
          
          // 2. Add a new file
          await writeFile(join(project.projectDir, 'b.ts'), 'export const B = 2;');

          // 3. Wait for re-generation to include the new file
          await waitForFileContent(outputPath, 'b.ts');
          const updatedContent = await readFile(outputPath, 'utf-8');
          expect(updatedContent).toContain('ยง (1) a.ts');
          expect(updatedContent).toContain('ยง (2) b.ts');
        });

        it('--watch: should re-generate when a tracked file is deleted', async () => {
          project = await setupTestProject({
            'a.ts': 'export const A = 1;',
            'b.ts': 'export const B = 2;',
          });
          const outputPath = join(project.projectDir, 'output.scn');
          const fileToDelete = join(project.projectDir, 'b.ts');

          watcherProc = Bun.spawn(['bun', 'run', 'src/cli.ts', '--watch', '-o', outputPath, '**/*.ts'], {
            cwd: project.projectDir,
          });

          // 1. Wait for initial generation
          await waitForFileContent(outputPath, 'b.ts');
          const initialContent = await readFile(outputPath, 'utf-8');
          expect(initialContent).toContain('b.ts');

          // 2. Delete the file
          await rm(fileToDelete);

          // 3. Wait for re-generation (b.ts should be gone)
          const start = Date.now();
          let contentHasB = true;
          while(contentHasB && Date.now() - start < 5000) {
              const content = await readFile(outputPath, 'utf-8');
              if (!content.includes('b.ts')) {
                  contentHasB = false;
              }
              await new Promise(resolve => setTimeout(resolve, 100));
          }

          expect(contentHasB).toBe(false);
          const updatedContent = await readFile(outputPath, 'utf-8');
          expect(updatedContent).toContain('a.ts');
          expect(updatedContent).not.toContain('b.ts');
        });

        it('should handle file paths with spaces correctly', async () => {
           project = await setupTestProject({
            '"my component".ts': 'export const MyComponent = 1;',
          });
          const outputPath = join(project.projectDir, '"output with spaces".scn');
          
          const proc = Bun.spawn(
            ['bun', 'run', 'src/cli.ts', '"my component".ts', '-o', '"output with spaces".scn'],
            { cwd: project.projectDir }
          );
          await proc.exited;

          expect(await proc.exitCode).toBe(0);
          const outputContent = await readFile(outputPath, 'utf-8');
          expect(outputContent).toContain('ยง (1) "\\"my component\\".ts"');
        });
      });
    patchStrategy: replace
snapshot:
  src/cli.ts: null
  test/ts/e2e/cli.test.ts: null
  test/ts/e2e/config-file.test.ts: null
  test/ts/e2e/filesystem.test.ts: null
  package.json: |
    {
      "name": "scn-ts",
      "module": "src/index.ts",
      "type": "module",
      "private": true,
      "devDependencies": {
        "@types/bun": "latest"
      },
      "peerDependencies": {
        "typescript": "^5"
      }
    }
  src/serializer.ts: >-
    import type {
      RankedCodeGraph,
      CodeNode,
      CodeEdge as RepographEdge,
      CodeNodeVisibility as Visibility,
      CssIntent,
      CodeNodeType,
    } from "repograph";


    // Allow for 'contains' and 'references' edges which might be produced by
    repograph

    // but not present in a minimal type definition.

    type CodeEdge = Omit<RepographEdge, 'type'> & {
      type: RepographEdge['type'] | 'contains' | 'references';
    };

    import { readFileSync } from "fs";

    import { join } from "path";


    type ScnSymbol = "โ" | "~" | "@" | "{}" | "โฐ" | "=:" | "โถ" | "ยถ" | "?";

    type QualifierSymbol = "+" | "-" | "..." | "!" | "o";

    type CssIntentSymbol = "๐" | "โ" | "๐ง";


    const ENTITY_TYPE_TO_SYMBOL: Record<CodeNodeType, ScnSymbol | undefined> = {
      class: 'โ',
      function: '~',
      method: '~',
      interface: '{}',
      enum: 'โฐ',
      type: '=:',
      html_element: 'โถ',
      css_rule: 'ยถ',
      namespace: 'โ',
      struct: 'โ',
      property: '@',
      field: '@',
      variable: '@',
      constant: '@',
      arrow_function: '~',
      constructor: '~',
      file: undefined,
      trait: undefined,
      impl: undefined,
      static: undefined,
      union: undefined,
      template: undefined,
    };


    const CSS_INTENT_TO_SYMBOL: Record<CssIntent, CssIntentSymbol> = {
      layout: '๐',
      typography: 'โ',
      appearance: '๐ง',
    };


    class ScnIdManager {
      private fileIdCounter = 1;
      private entityIdCounters = new Map<string, number>(); // file path -> counter
      private repographIdToScnId = new Map<string, string>();
      private fileRepoIdToPath = new Map<string, string>();

      constructor(sortedFileNodes: CodeNode[], nodesByFile: Map<string, CodeNode[]>) {
        for (const fileNode of sortedFileNodes) {
          const fileId = `${this.fileIdCounter++}`;
          this.repographIdToScnId.set(fileNode.id, fileId);
          this.fileRepoIdToPath.set(fileNode.id, fileNode.filePath);
          this.entityIdCounters.set(fileNode.filePath, 1);

          const entities = nodesByFile.get(fileNode.filePath) || [];
          entities.sort((a, b) => a.startLine - b.startLine);

          for (const entityNode of entities) {
            const entityCounter = this.entityIdCounters.get(entityNode.filePath)!;
            const entityId = `${fileId}.${entityCounter}`;
            this.repographIdToScnId.set(entityNode.id, entityId);
            this.entityIdCounters.set(entityNode.filePath, entityCounter + 1);
          }
        }
      }

      getScnId(repographId: string): string | undefined {
        return this.repographIdToScnId.get(repographId);
      }

      isFilePath(repographId: string): boolean {
        return this.fileRepoIdToPath.has(repographId);
      }
    }


    // Cache for source file contents to avoid reading files multiple times

    const sourceFileCache = new Map<string, string>();


    const getSourceContent = (filePath: string, rootDir?: string): string => {
      const fullPath = rootDir ? join(rootDir, filePath) : filePath;
      if (!sourceFileCache.has(fullPath)) {
        try {
          const content = readFileSync(fullPath, 'utf-8');
          sourceFileCache.set(fullPath, content);
        } catch {
          sourceFileCache.set(fullPath, '');
        }
      }
      return sourceFileCache.get(fullPath) || '';
    };


    const isExported = (node: CodeNode, rootDir?: string): boolean => {
      if (node.type === 'file') return false;
      
      const sourceContent = getSourceContent(node.filePath, rootDir);
      if (!sourceContent) return false;
      
      // For class members (properties, methods), check if they're public by default
      // In TypeScript, class members are public by default unless marked private/protected
      if (node.type === 'property' || node.type === 'field' || node.type === 'method') {
        // Check if it's explicitly marked as private or protected
        const memberName = node.name.includes('.') ? node.name.split('.').pop() : node.name;
        const privatePattern = new RegExp(`private\\s+${memberName}\\b`);
        const protectedPattern = new RegExp(`protected\\s+${memberName}\\b`);
        
        if (privatePattern.test(sourceContent) || protectedPattern.test(sourceContent)) {
          return false;
        }
        // If not explicitly private/protected, it's public
        return true;
      }
      
      // Check for export patterns
      const exportPatterns = [
        new RegExp(`export\\s+class\\s+${node.name}\\b`),
        new RegExp(`export\\s+function\\s+${node.name}\\b`),
        new RegExp(`export\\s+interface\\s+${node.name}\\b`),
        new RegExp(`export\\s+namespace\\s+${node.name}\\b`),
        new RegExp(`export\\s+const\\s+${node.name}\\b`),
        new RegExp(`export\\s+let\\s+${node.name}\\b`),
        new RegExp(`export\\s+var\\s+${node.name}\\b`),
        new RegExp(`export\\s+default\\s+class\\s+${node.name}\\b`),
        new RegExp(`export\\s+default\\s+function\\s+${node.name}\\b`),
        new RegExp(`export\\s*{[^}]*\\b${node.name}\\b[^}]*}`),
      ];
      
      return exportPatterns.some(pattern => pattern.test(sourceContent));
    };


    const getVisibilitySymbol = (visibility?: Visibility, node?: CodeNode,
    rootDir?: string): '+' | '-' | undefined => {
      if (visibility === 'public') return '+';
      if (visibility === 'private') return '-';

      // In TypeScript, class members are public by default.
      if (node && (node.type === 'method' || node.type === 'property' || node.type === 'field')) {
          const source = getSourceContent(node.filePath, rootDir);
          // A simple check to see if it is explicitly private/protected. If not, it's public.
          const line = (source.split('\n')[node.startLine - 1] || '').trim();
          if (!line.startsWith('private') && !line.startsWith('protected')) {
            return '+';
          }
      }

      // If repograph doesn't provide visibility info, infer it from source for other types
      if (node && isExported(node, rootDir)) {
        return '+';
      }

      return undefined;
    };


    const getNodeSymbol = (node: CodeNode): ScnSymbol => {
      // Heuristic: Treat PascalCase functions as components (e.g., React)
      if ((node.type === 'function' || node.type === 'arrow_function') && /^[A-Z]/.test(node.name)) {
        return 'โ';
      }
      // Heuristic: Treat uppercase constants/variables as containers (module pattern)
      if ((node.type === 'variable' || node.type === 'constant') && /^[A-Z]/.test(node.name)) {
        return 'โ';
      }
      return ENTITY_TYPE_TO_SYMBOL[node.type] ?? '?';
    };


    const getQualifiers = (node: CodeNode, rootDir?: string): { access?: '+' |
    '-'; others: QualifierSymbol[] } => {
      const qualifiers: { access?: '+' | '-'; others: QualifierSymbol[] } = { others: [] };
      const visibilitySymbol = getVisibilitySymbol(node.visibility, node, rootDir);
      if (visibilitySymbol) qualifiers.access = visibilitySymbol;

      const others: QualifierSymbol[] = [];
      if (node.isAsync) others.push('...');
      if (node.canThrow) others.push('!');
      if (node.isPure) others.push('o');
      qualifiers.others = others;
      
      return qualifiers;
    };


    const formatCssIntents = (intents: readonly CssIntent[] = []): string => {
      if (intents.length === 0) return '';
      // Sort intents alphabetically first, then map to symbols
      const sortedIntents = [...intents].sort();
      const symbols = sortedIntents.map(intent => CSS_INTENT_TO_SYMBOL[intent] ?? '');
      return `{ ${symbols.join(' ')} }`;
    };


    const formatFunctionSignature = (snippet: string): string => {
      // Find parameters part, e.g., (a: string, b: number)
      const paramsMatch = snippet.match(/\(([^)]*)\)/);
      let params = '()';
      if (paramsMatch) {
        // Replace type annotations with #
        const paramContent = paramsMatch[1].replace(/:[^\,)]+/g, ': #');
        params = `(${paramContent})`;
      }

      // Find return type, e.g., ): string
      const returnMatch = snippet.match(/\)\s*:\s*([\w\.<>\[\]\| &]+)/);
      let returnType = '';
      if (returnMatch && returnMatch[1]) {
        const type = returnMatch[1].trim();
        if (type !== 'void' && type !== 'any' && type !== 'unknown') {
           returnType = `: #${type}`;
        }
      }

      return `${params}${returnType}`;
    }


    const formatJsxAttributes = (snippet: string): string => {
        const attrs = [];
        const idMatch = snippet.match(/id="([^"]+)"/);
        if (idMatch) attrs.push(`id:#${idMatch[1]}`);
        
        const classMatch = snippet.match(/className="([^"]+)"/);
        if (classMatch) {
            const classes = classMatch[1].split(' ').map(c => `.${c}`).join(' ');
            attrs.push(`class:${classes}`);
        }
        
        return attrs.length > 0 ? ` [ ${attrs.join(' ')} ]` : '';
    }


    const formatSignature = (node: CodeNode): string => {
      const isComponent = (node.type === 'function' || node.type === 'arrow_function') && /^[A-Z]/.test(node.name);

      if (isComponent && node.codeSnippet) {
        const propMatch = node.codeSnippet.match(/\(\s*\{([^}]+)\}/);
        if (propMatch) {
          const props = propMatch[1].split(',').map(p => p.trim().split(/[:=]/)[0].trim()).filter(Boolean);
          const propsString = props.map(p => `${p}:#`).join(', ');
          return `{ props: { ${propsString} } }`;
        }
        return ''; // Component with no destructured props
      }

      // For functions, format as name() instead of showing full code snippet
      if ((node.type === 'function' || node.type === 'method' || node.type === 'constructor' || node.type === 'arrow_function') && node.codeSnippet) {
        return formatFunctionSignature(node.codeSnippet);
      }
      
      // For JSX/HTML elements, show attributes
      if (node.type === 'html_element' && node.codeSnippet) {
        return formatJsxAttributes(node.codeSnippet);
      }

      // For CSS rules, show intents
      if (node.type === 'css_rule' && node.cssIntents) {
        return formatCssIntents(node.cssIntents);
      }

      // For type aliases, show the aliased type
      if (node.type === 'type' && node.codeSnippet) {
         const match = node.codeSnippet.match(/=\s*(.+);?/);
         return match ? `= ${match[1].trim().replace(/;$/, '')}` : '';
      }

      // For variables/constants, show the value if it's simple
      if ((node.type === 'variable' || node.type === 'constant') && node.codeSnippet) {
        // For uppercase constants that are treated as modules (โ symbol), show different formatting
        if (/^[A-Z]/.test(node.name)) {
          // If it's an object literal, show it without = prefix (module pattern)
          if (node.codeSnippet.startsWith('{') && node.codeSnippet.endsWith('}')) {
            return node.codeSnippet;
          }
        }
        
        // For regular variables/constants, add = prefix if needed
        if (!node.codeSnippet.includes('=')) {
          return `= ${node.codeSnippet}`;
        }
        // Extract simple values like "123", "'value'", etc.
        const match = node.codeSnippet.match(/=\s*(.+)$/);
        if (match && match[1]) {
          return `= ${match[1].trim()}`;
        }
        // If no assignment found, just return the snippet
        return node.codeSnippet;
      }
      
      // For other container types, show their code snippet if available
      if (node.codeSnippet && (node.type === 'class' || node.type === 'interface' || node.type === 'namespace')) {
        return node.codeSnippet;
      }
      
      return '';
    };


    const formatNode = (node: CodeNode, graph: RankedCodeGraph, idManager:
    ScnIdManager, rootDir?: string, level = 0): string => {
      const symbol = getNodeSymbol(node);
      const { access, others } = getQualifiers(node, rootDir);
      const signature = formatSignature(node);
      const scnId = idManager.getScnId(node.id);
      const id = scnId ? `(${scnId})` : '';
      const indent = '  '.repeat(level + 1);

      // Build the main line: qualifiers symbol id name signature
      const parts = [];
      if (access) parts.push(access);
      parts.push(symbol);
      if (id) parts.push(id);

      // For functions, combine name and signature without space, unless it's a component
      const isComponent = (node.type === 'function' || node.type === 'arrow_function') && /^[A-Z]/.test(node.name);
      if ((node.type === 'function' || node.type === 'method' || node.type === 'constructor' || node.type === 'arrow_function') && !isComponent) {
        const displayName = node.name.includes('.') ? node.name.split('.').pop() || node.name : node.name;
        parts.push(displayName + signature);
      } else {
        const displayName = (node.type === 'property' || node.type === 'field' || node.type === 'html_element') && node.name.includes('.')
          ? node.name.split('.').pop() || node.name
          : node.name;
        parts.push(displayName);
        if (signature) parts.push(signature);
      }

      let mainLine = indent + parts.join(' ');
      if (others.length > 0) {
        mainLine += ` ${others.sort().join(' ')}`;
      }

      const formatLinks = (prefix: string, edges: readonly CodeEdge[]): string => {
        if (edges.length === 0) return '';
        const links = edges.map((edge: CodeEdge) => {
          const isCallerLink = prefix === '<-';
          const targetRepographId = isCallerLink ? edge.fromId : edge.toId;
          const targetNode = graph.nodes.get(targetRepographId);
          let targetScnId = idManager.getScnId(targetRepographId);

          // Per spec, file-level dependencies use a .0 suffix.
          // This applies if the target of the link is a file itself.
          if (targetNode?.type === 'file') {
            targetScnId = `${targetScnId}.0`;
          }
          return `(${targetScnId})`;
        }).filter(Boolean).sort().join(', ');

        if (!links) return '';
        return `\n${indent}  ${prefix} ${links}`;
      };

      const dependencyEdges = (graph.edges as CodeEdge[]).filter(edge => edge.fromId === node.id && edge.type !== 'contains');
      const callerEdges = (graph.edges as CodeEdge[]).filter(edge => edge.toId === node.id && edge.type !== 'imports' && edge.type !== 'contains');

      return mainLine + formatLinks('->', dependencyEdges) + formatLinks('<-', callerEdges);
    };


    const serializeFile = (
      fileNode: CodeNode,
      symbols: CodeNode[],
      graph: RankedCodeGraph,
      idManager: ScnIdManager,
      rootDir?: string
    ): string => {
      const scnId = idManager.getScnId(fileNode.id) ?? '';

      const formatFileLinks = (prefix: string, edges: readonly CodeEdge[]): string => {
        if (edges.length === 0) return '';
        const links = edges.map((edge: CodeEdge) => {
          const targetId = prefix === '->' ? edge.toId : edge.fromId;
          const targetScnId = idManager.getScnId(targetId);
          return `(${targetScnId}.0)`;
        }).sort().join(', ');
        if (!links) return '';
        return `\n  ${prefix} ${links}`;
      };

      const fileDependencies = graph.edges.filter(e => e.type === 'imports' && e.fromId === fileNode.id);
      const fileCallers = graph.edges.filter(e => e.type === 'imports' && e.toId === fileNode.id);

      let header = `ยง (${scnId}) ${fileNode.filePath}`;
      const fileDepLine = formatFileLinks('->', fileDependencies);
      if (fileDepLine) header += fileDepLine;
      const fileCallerLine = formatFileLinks('<-', fileCallers);
      if (fileCallerLine) header += fileCallerLine;

      // Hierarchical rendering
      const nodeWrappers = symbols.map(s => ({ node: s, children: [] as {node: CodeNode, children: any[]}[] })).sort((a,b) => a.node.startLine - b.node.startLine);
      const nodeMap = new Map(nodeWrappers.map(w => [w.node.id, w]));
      const topLevelSymbols: typeof nodeWrappers = [];

      for (let i = 0; i < nodeWrappers.length; i++) {
        const currentWrapper = nodeWrappers[i];
        let parentWrapper = null;
        
        // Find the tightest parent by looking backwards through the sorted list
        for (let j = i - 1; j >= 0; j--) {
            const potentialParentWrapper = nodeWrappers[j];
            if (currentWrapper.node.startLine >= potentialParentWrapper.node.startLine && currentWrapper.node.endLine <= potentialParentWrapper.node.endLine) {
                parentWrapper = potentialParentWrapper;
                break;
            }
        }
        
        if (parentWrapper) {
            parentWrapper.children.push(currentWrapper);
        } else {
            topLevelSymbols.push(currentWrapper);
        }
      }

      const nodeLines: string[] = [];
      const processNode = (wrapper: {node: CodeNode, children: any[]}, level: number) => {
        nodeLines.push(formatNode(wrapper.node, graph, idManager, rootDir, level));
        for (const childWrapper of wrapper.children) {
          processNode(childWrapper, level + 1);
        }
      };

      for (const wrapper of topLevelSymbols) {
        processNode(wrapper, 0);
      }

      return [header, ...nodeLines].join('\n');
    };


    /**
     * Serializes a RankedCodeGraph into the SCN text format.
     * This function is the core rendering layer of `scn-ts`.
     *
     * @param graph - The `RankedCodeGraph` produced by `repograph`.
     * @param rootDir - The root directory of the project (for reading source files).
     * @returns A string containing the full SCN map.
     */
    export const serializeGraph = (graph: RankedCodeGraph, rootDir?: string):
    string => {
      const nodesByFile = new Map<string, CodeNode[]>(); // filePath -> nodes
      const fileNodes: CodeNode[] = [];

      for (const node of graph.nodes.values()) {
        if (node.type === 'file') {
          fileNodes.push(node);
          nodesByFile.set(node.filePath, []);
        } else {
          if (!nodesByFile.has(node.filePath)) {
            // This case can happen if repograph finds an entity but not its parent file.
            // We'll create a dummy map entry, but it won't be processed without a file node.
            nodesByFile.set(node.filePath, []); 
          }
          nodesByFile.get(node.filePath)!.push(node);
        }
      }

      const sortedFileNodes = fileNodes.sort((a, b) => a.filePath.localeCompare(b.filePath));
      const idManager = new ScnIdManager(sortedFileNodes, nodesByFile);

      const scnParts = sortedFileNodes.map(fileNode => {
        const symbols = nodesByFile.get(fileNode.filePath) || [];
        // Sort symbols by line number to ensure deterministic output for hierarchical processing
        symbols.sort((a,b) => a.startLine - b.startLine);
        return serializeFile(fileNode, symbols, graph, idManager, rootDir);
      });

      return scnParts.join('\n\n');
    };
approved: true
