uuid: 4f147986-e802-44f2-98ed-738914d3f324
projectId: scn-ts
createdAt: '2025-07-21T13:40:52.057Z'
linesAdded: 35
linesRemoved: 15
gitCommitMsg: 'fix(repograph): resolve test failures in analyzer and cli'
promptSummary: >-
  Fix a suite of failing tests in the `repograph` subproject. The failures span
  the CLI, multi-language analysis, and detailed code node property extraction.
  The fixes involve updating the CLI version command, enhancing the TypeScript
  analyzer to capture qualifiers (like visibility and async), correcting code
  snippet generation, and fixing bugs in relationship (edge) creation.
reasoning:
  - >-
    Hello! As anton, your expert AI programmer, I've analyzed the test failures
    and identified the root causes in the analysis pipeline and CLI logic. The
    issues stem from incomplete symbol processing in `repograph`, particularly
    for TypeScript, and a small bug in the CLI's version reporting.
  - >-
    Here are the precise modifications to fix the failing tests, while adhering
    to our principle of keeping `repograph` language-agnostic and not
    introducing SCN-specific notation into the core analyzer.
  - '### `repograph/src/index.ts`'
  - >-
    First, I'll fix the CLI's version reporting. The test was failing because
    the `--version` flag produced no output. I'll modify it to correctly read
    the version from `repograph/package.json` and print it to standard output,
    which will satisfy the e2e test.
  - '### `repograph/src/pipeline/analyze.ts`'
  - >-
    Next, I will apply a series of fixes to the Tree-sitter analyzer. These
    changes will resolve the failures in `analyze.test.ts`,
    `codenode-qualifiers.test.ts`, and `multi-language.test.ts`.
  - >-
    1.  **Qualifier & Parameter Extraction**: The TypeScript-specific handler
    for methods and fields was not extracting qualifiers like `public`, `async`,
    or parameter/return types. I've enhanced it to parse these details, which
    will fix all failures in `codenode-qualifiers.test.ts`.
  - >-
    2.  **Code Snippet Generation**: The logic for creating code snippets was
    incorrect for classes, capturing only the body. I've corrected this to
    capture the full class definition, fixing the snippet-related test failures.
  - '3.  **Relationship & Edge Creation**:'
  - >-
    *   The logic to prevent duplicate edges was too aggressive, ignoring the
    edge `type`. I've fixed it to allow different types of relationships (e.g.,
    `calls` and `inherits`) between the same two nodes.
  - >-
    *   A `'uses'` edge type was being created for references, which is not a
    valid type in `CodeEdge`. I've mapped this to `'calls'`, as it's the closest
    valid semantic relationship.
  - These combined changes will make the analyzer more accurate and robust.
  - >-
    These changes should resolve all the reported test failures and make the
    `repograph` analyzer significantly more accurate and feature-complete.
operations:
  - type: write
    path: repograph/src/index.ts
    content: |-
      <<<<<<< SEARCH
          if (args.includes('--version') || args.includes('-v')) {
            // In a real app, you'd get this from package.json
            logger.info('0.1.0');
            process.exit(0);
          }
      =======
          if (args.includes('--version') || args.includes('-v')) {
            const { readFileSync } = await import('node:fs');
            const pkgPath = new URL('../package.json', import.meta.url);
            const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
            console.log(pkg.version);
            process.exit(0);
          }
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: repograph/src/pipeline/analyze.ts
    content: >-
      --- repograph/src/pipeline/analyze.ts

      +++ repograph/src/pipeline/analyze.ts

      @@ -23,12 +23,14 @@
         symbolType: CodeNodeType;
         processedSymbols: Set<string>;
         fileState: Record<string, any>;
      +  childCaptures: TSMatch[];
       };
       
       const pythonHandler: Partial<LanguageHandler> = {
         getSymbolNameNode: (declarationNode: TSNode) => {
           if (declarationNode.type === 'expression_statement') {
      @@ -133,7 +135,7 @@
           }
           return declarationNode.childForFieldName('name');
         },
      -  processComplexSymbol: ({ nodes, file, node, symbolType,
      processedSymbols, fileState }) => {

      +  processComplexSymbol: ({ nodes, file, node, symbolType,
      processedSymbols, fileState, childCaptures }) => {
           if (symbolType !== 'method' && symbolType !== 'field') return false;
           const classParent = node.parent?.parent; // class_body -> class_declaration
           if (classParent?.type === 'class_declaration') {
      @@ -165,11 +167,29 @@
                     codeSnippet = node.text?.split('{')[0]?.trim() || '';
                   }
                   
      +            const qualifiers: { [key: string]: TSNode } = {};

      +            for (const capture of childCaptures) {

      +              qualifiers[capture.name] = capture.node;

      +            }

      +            const visibilityNode = qualifiers['qualifier.visibility'];

      +            const visibility = visibilityNode ?
      (getNodeText(visibilityNode, file.content) as CodeNodeVisibility) :
      undefined;

      +            const returnTypeNode = qualifiers['symbol.returnType'];

      +            const returnType = returnTypeNode ?
      getNodeText(returnTypeNode, file.content).replace(/^:\s*/, '') :
      undefined;

      +            const parametersNode = qualifiers['symbol.parameters'];

      +            const parameters = parametersNode &&
      tsLangHandler.parseParameters ?
      tsLangHandler.parseParameters(parametersNode, file.content) : undefined;

      +            const canThrow = childCaptures.some(c => c.name ===
      'qualifier.throws');

      +
                   nodes.set(unqualifiedSymbolId, {
                     id: unqualifiedSymbolId, type: symbolType, name: methodName, filePath: file.path,
                     startLine: getLineFromIndex(file.content, node.startIndex),
                     endLine: getLineFromIndex(file.content, node.endIndex),
                     codeSnippet,
      +              ...(qualifiers['qualifier.async'] && { isAsync: true }),

      +              ...(qualifiers['qualifier.static'] && { isStatic: true }),

      +              ...(visibility && { visibility }),

      +              ...(returnType && { returnType }),

      +              ...(parameters && { parameters }),

      +              ...(canThrow && { canThrow: true }),
                   });
                 }
                 
      @@ -395,9 +415,8 @@
           );
       
           processSymbol(
      -      { ...graph, file, node, symbolType, processedSymbols, fileState },

      +      { ...graph, file, node, symbolType, processedSymbols, fileState,
      childCaptures },
             langConfig
      -,

      -      childCaptures
           );
         }
       }
      @@ -405,12 +424,10 @@
       /**
        * Process a single symbol definition.
        */
      -function processSymbol(

      -  context: ProcessSymbolContext,

      +function processSymbol(

      +  context: ProcessSymbolContext,
         langConfig: LanguageConfig,
      -  childCaptures: TSMatch[]
       ): void {
      -  const { nodes, file, node, symbolType, processedSymbols } = context;

      +  const { nodes, file, node, symbolType, processedSymbols, childCaptures
      } = context;
         const handler = getLangHandler(langConfig.name);
       
         if (handler.shouldSkipSymbol(node, symbolType, langConfig.name)) return;
      @@ -457,14 +474,15 @@
       
           // Extract code snippet
           let codeSnippet = '';
      -    if (symbolType === 'variable' || symbolType === 'constant') {

      -      const fullText = file.content.slice(node.startIndex,
      node.endIndex);

      +    if (symbolType === 'variable' || symbolType === 'constant' ||
      symbolType === 'property') {

      +      const fullText = node.text;
             const assignmentMatch = fullText.match(/=\s*(.+)$/s);
             if (assignmentMatch) {
               codeSnippet = assignmentMatch[1].trim();
             }
      -    } else {

      -      const snippetWithEquals = file.content.slice(nameNode.endIndex,
      node.endIndex).replace(/^{/, '').trim();

      -      codeSnippet = snippetWithEquals.startsWith('=') ?
      snippetWithEquals.substring(1).trim() : snippetWithEquals;

      +    } else if (symbolType === 'function' || symbolType === 'method' ||
      symbolType === 'arrow_function' || symbolType === 'constructor') {

      +      const bodyStart = node.text.indexOf('{');

      +      codeSnippet = (bodyStart > -1 ? node.text.slice(0, bodyStart) :
      node.text).trim();

      +    } else {

      +      codeSnippet = node.text;
           }
       
           nodes.set(symbolId, {
      @@ -501,8 +519,8 @@
             const importIdentifier = getNodeText(node, file.content).replace(/['"`]/g, '');
             const importedFilePath = handler.resolveImport(file.path, importIdentifier, allFilePaths);
             if (importedFilePath && graph.nodes.has(importedFilePath)) {
      -        const edge: CodeEdge = { fromId: file.path, toId:
      importedFilePath, type: 'imports' };

      -        if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId ===
      edge.toId)) {

      +        const edge: CodeEdge = { fromId: file.path, toId:
      importedFilePath, type: 'imports' };

      +        if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId ===
      edge.toId && e.type === edge.type)) {
                 graph.edges.push(edge);
               }
             }
      @@ -528,9 +546,9 @@
             
             const edgeType = subtype === 'inheritance' ? 'inherits' : 
                             subtype === 'implementation' ? 'implements' : 
      -                      subtype === 'call' ? 'calls' : 'uses';

      +                      'calls'; // Fallback for 'call' and 'reference'
             const edge: CodeEdge = { fromId, toId: toNode.id, type: edgeType };
      -      if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId ===
      edge.toId)) {

      +      if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId ===
      edge.toId && e.type === edge.type)) {
               graph.edges.push(edge);
             }
           }
    patchStrategy: new-unified
snapshot:
  repograph/src/index.ts: |
    #!/usr/bin/env bun

    import { logger } from './utils/logger.util.js';
    import { RepoGraphError } from './utils/error.util.js';
    // High-Level API for simple use cases
    import { generateMap as executeGenerateMap } from './high-level.js';
    import type { RepoGraphOptions as IRepoGraphOptions } from './types.js';

    export { generateMap, analyzeProject } from './high-level.js';

    // Low-Level API for composition and advanced use cases
    export { createMapGenerator } from './composer.js';

    // Default pipeline component factories
    export { createDefaultDiscoverer } from './pipeline/discover.js';
    export { createTreeSitterAnalyzer } from './pipeline/analyze.js';
    export { createPageRanker, createGitRanker } from './pipeline/rank.js';
    export { createMarkdownRenderer } from './pipeline/render.js';

    // Logger utilities
    export { logger } from './utils/logger.util.js';
    export type { Logger, LogLevel } from './utils/logger.util.js';

    // Core types for building custom components
    export type {
      FileContent,
      CodeNode,
      CodeNodeType,
      CodeNodeVisibility,
      CodeEdge,
      CodeGraph,
      RankedCodeGraph,
      RepoGraphMap,
      RepoGraphOptions,
      RendererOptions,
      FileDiscoverer,
      CssIntent,
      Analyzer,
      Ranker,
      Renderer,
    } from './types.js';

    // This section runs only when the script is executed directly from the CLI
    import { fileURLToPath } from 'node:url';
    import path from 'node:path';

    const isRunningDirectly = () => {
      if (typeof process.argv[1] === 'undefined') return false;
      const runningFile = path.resolve(process.argv[1]);
      const currentFile = fileURLToPath(import.meta.url);
      return runningFile === currentFile;
    };

    if (isRunningDirectly()) {
      (async () => {
        const args = process.argv.slice(2);

        if (args.includes('--help') || args.includes('-h')) {
          console.log(`
    Usage: repograph [root] [options]

    Arguments:
      root                     The root directory of the repository to analyze. Defaults to the current working directory.

    Options:
      -h, --help               Display this help message.
      -v, --version            Display the version number.
      --output <path>          Path to the output Markdown file. (default: "repograph.md")
      --include <pattern>      Glob pattern for files to include. Can be specified multiple times.
      --ignore <pattern>       Glob pattern for files to ignore. Can be specified multiple times.
      --no-gitignore           Do not respect .gitignore files.
      --ranking-strategy <name> The ranking strategy to use. (default: "pagerank", options: "pagerank", "git-changes")
      --log-level <level>      Set the logging level. (default: "info", options: "silent", "error", "warn", "info", "debug")

    Output Formatting:
      --no-header              Do not include the main "RepoGraph" header.
      --no-overview            Do not include the project overview section.
      --no-mermaid             Do not include the Mermaid dependency graph.
      --no-file-list           Do not include the list of top-ranked files.
      --no-symbol-details      Do not include the detailed file and symbol breakdown.
      --top-file-count <num>   Set the number of files in the top list. (default: 10)
      --file-section-separator <str> Custom separator for file sections. (default: "---")
      --no-symbol-relations    Hide symbol relationship details (e.g., calls, implements).
      --no-symbol-line-numbers Hide line numbers for symbols.
      --no-symbol-snippets     Hide code snippets for symbols.
      --max-relations-to-show <num> Max number of 'calls' relations to show per symbol. (default: 3)
        `);
          process.exit(0);
        }

        if (args.includes('--version') || args.includes('-v')) {
          // In a real app, you'd get this from package.json
          logger.info('0.1.0');
          process.exit(0);
        }

        // We need a mutable version of the options to build it from arguments.
        const options: {
          root?: string;
          output?: string;
          include?: readonly string[];
          ignore?: readonly string[];
          noGitignore?: boolean;
          rankingStrategy?: 'pagerank' | 'git-changes';
          logLevel?: IRepoGraphOptions['logLevel'];
          rendererOptions?: IRepoGraphOptions['rendererOptions'];
        } = {};
        const includePatterns: string[] = [];
        const ignorePatterns: string[] = [];
        // We need a mutable version of rendererOptions to build from CLI args
        const rendererOptions: {
          customHeader?: string;
          includeHeader?: boolean;
          includeOverview?: boolean;
          includeMermaidGraph?: boolean;
          includeFileList?: boolean;
          topFileCount?: number;
          includeSymbolDetails?: boolean;
          fileSectionSeparator?: string;
          symbolDetailOptions?: {
            includeRelations?: boolean;
            includeLineNumber?: boolean;
            includeCodeSnippet?: boolean;
            maxRelationsToShow?: number;
          };
        } = {};

        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          if (!arg) {
            continue;
          }
          switch (arg) {
            case '--output':
              options.output = args[++i];
              break;
            case '--include':
              includePatterns.push(args[++i] as string);
              break;
            case '--ignore':
              ignorePatterns.push(args[++i] as string);
              break;
            case '--no-gitignore':
              options.noGitignore = true;
              break;
            case '--ranking-strategy':
              options.rankingStrategy = args[++i] as IRepoGraphOptions['rankingStrategy'];
              break;
            case '--log-level':
              options.logLevel = args[++i] as IRepoGraphOptions['logLevel'];
              break;
            // --- Renderer Options ---
            case '--no-header':
              rendererOptions.includeHeader = false;
              break;
            case '--no-overview':
              rendererOptions.includeOverview = false;
              break;
            case '--no-mermaid':
              rendererOptions.includeMermaidGraph = false;
              break;
            case '--no-file-list':
              rendererOptions.includeFileList = false;
              break;
            case '--no-symbol-details':
              rendererOptions.includeSymbolDetails = false;
              break;
            case '--top-file-count':
              rendererOptions.topFileCount = parseInt(args[++i] as string, 10);
              break;
            case '--file-section-separator':
              rendererOptions.fileSectionSeparator = args[++i];
              break;
            case '--no-symbol-relations':
              rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeRelations: false };
              break;
            case '--no-symbol-line-numbers':
              rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeLineNumber: false };
              break;
            case '--no-symbol-snippets':
              rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeCodeSnippet: false };
              break;
            case '--max-relations-to-show':
              rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), maxRelationsToShow: parseInt(args[++i] as string, 10) };
              break;
            default:
              if (!arg.startsWith('-')) {
                options.root = arg;
              }
              break;
          }
        }

        if (includePatterns.length > 0) {
          options.include = includePatterns;
        }
        if (ignorePatterns.length > 0) {
          options.ignore = ignorePatterns;
        }
        if (Object.keys(rendererOptions).length > 0) {
          options.rendererOptions = rendererOptions;
        }

        const finalOutput = path.resolve(options.root || process.cwd(), options.output || 'repograph.md');

        logger.info(`Starting RepoGraph analysis for "${path.resolve(options.root || process.cwd())}"...`);

        try {
          await executeGenerateMap(options);
          const relativePath = path.relative(process.cwd(), finalOutput);
          logger.info(`\n✅ Success! RepoGraph map saved to ${relativePath}`);
        } catch (error: unknown) {
          if (error instanceof RepoGraphError) {
            logger.error(`\n❌ Error generating RepoGraph map: ${error.message}`);
          } else {
            logger.error('\n❌ An unknown error occurred while generating the RepoGraph map.', error);
          }
          process.exit(1);
        }
      })().catch((error) => {
        console.error('Fatal error:', error);
        process.exit(1);
      });
    }
  repograph/src/pipeline/analyze.ts: >-
    import path from 'node:path';

    import { createParserForLanguage } from '../tree-sitter/languages.js';

    import { getLanguageConfigForFile, type LanguageConfig } from
    '../tree-sitter/language-config.js';

    import type { Analyzer, CodeNode, CodeNodeType, CodeNodeVisibility,
    FileContent, CodeEdge } from '../types.js';

    import type { Node as TSNode, QueryCapture as TSMatch } from
    'web-tree-sitter';

    import { logger } from '../utils/logger.util.js';

    import { ParserError } from '../utils/error.util.js';


    // --- UTILITY FUNCTIONS ---


    const getNodeText = (node: TSNode, content: string): string =>
    content.slice(node.startIndex, node.endIndex);

    const getLineFromIndex = (content: string, index: number): number =>
    content.substring(0, index).split('\n').length;

    const normalizePath = (p: string): string => p.replace(/\\/g, '/');


    // --- LANGUAGE-SPECIFIC LOGIC ---


    type LanguageHandler = {
      preProcessFile?: (file: FileContent, captures: TSMatch[]) => Record<string, any>;
      shouldSkipSymbol: (node: TSNode, symbolType: CodeNodeType, langName: string) => boolean;
      getSymbolNameNode: (declarationNode: TSNode, originalNode: TSNode) => TSNode | null;
      processComplexSymbol?: (context: ProcessSymbolContext) => boolean;
      parseParameters?: (paramsNode: TSNode, content: string) => { name: string; type?: string }[];
      resolveImport: (fromFile: string, importIdentifier: string, allFiles: string[]) => string | null;
    };


    type ProcessSymbolContext = {
      nodes: Map<string, CodeNode>;
      file: FileContent;
      node: TSNode;
      symbolType: CodeNodeType;
      processedSymbols: Set<string>;
      fileState: Record<string, any>;
    };


    const pythonHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'expression_statement') {
          const assignmentNode = declarationNode.namedChild(0);
          if (assignmentNode?.type === 'assignment') {
            return assignmentNode.childForFieldName('left');
          }
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const goLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        const nodeType = declarationNode.type;
        if (['type_declaration', 'const_declaration', 'var_declaration'].includes(nodeType)) {
          const spec = declarationNode.namedChild(0);
          if (spec && ['type_spec', 'const_spec', 'var_spec'].includes(spec.type)) {
            return spec.childForFieldName('name');
          }
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const cLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'type_definition') {
          const lastChild = declarationNode.namedChild(declarationNode.namedChildCount - 1);
          if (lastChild?.type === 'type_identifier') return lastChild;
        }
        if (declarationNode.type === 'function_definition') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') {
            const nameNode = declarator.childForFieldName('declarator');
            if (nameNode?.type === 'identifier') return nameNode;
          }
        }
        if (declarationNode.type === 'field_declaration') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') {
            return declarator.childForFieldName('declarator');
          }
          return declarator;
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const tsLangHandler: Partial<LanguageHandler> = {
      preProcessFile: (_file, captures) => {
        const classNames = new Map<string, number>();
        const duplicateClassNames = new Set<string>();
        const seenClassNodes = new Set<number>();

        for (const { name, node } of captures) {
          if (name === 'class.definition') {
            let classNode = node.type === 'export_statement' ? (node.namedChildren[0] ?? node) : node;
            if (classNode.type === 'class_declaration' && !seenClassNodes.has(classNode.startIndex)) {
              seenClassNodes.add(classNode.startIndex);
              const nameNode = classNode.childForFieldName('name');
              if (nameNode) {
                const className = nameNode.text;
                const count = classNames.get(className) || 0;
                classNames.set(className, count + 1);
                if (count + 1 > 1) duplicateClassNames.add(className);
              }
            }
          }
        }
        return { duplicateClassNames };
      },
      shouldSkipSymbol: (node, symbolType, langName) => {
        if (langName !== 'typescript') return false;
        const valueNode = node.childForFieldName('value');
        if (valueNode?.type !== 'arrow_function') return false;
        return (symbolType === 'field' && node.type === 'public_field_definition') ||
          (symbolType === 'variable' && node.type === 'variable_declarator');
      },
      getSymbolNameNode: (declarationNode, originalNode) => {
        if (originalNode.type === 'variable_declarator' || originalNode.type === 'public_field_definition') { // Arrow function
          return originalNode.childForFieldName('name');
        }
        if (declarationNode.type === 'export_statement') {
          const lexicalDecl = declarationNode.namedChildren[0];
          if (lexicalDecl?.type === 'lexical_declaration') {
            const varDeclarator = lexicalDecl.namedChildren[0];
            if (varDeclarator?.type === 'variable_declarator') {
              return varDeclarator.childForFieldName('name');
            }
          }
        }
        return declarationNode.childForFieldName('name');
      },
      processComplexSymbol: ({ nodes, file, node, symbolType, processedSymbols, fileState }) => {
        if (symbolType !== 'method' && symbolType !== 'field') return false;
        const classParent = node.parent?.parent; // class_body -> class_declaration
        if (classParent?.type === 'class_declaration') {
          const classNameNode = classParent.childForFieldName('name');
          if (classNameNode) {
            const className = classNameNode.text;
            const nameNode = node.childForFieldName('name');
            // The check for duplicateClassNames is important to avoid ambiguity.
            // We remove the dependency on checking if the class has been processed first,
            // because the order of captures from tree-sitter is not guaranteed to be in source order.
            // This makes the analysis more robust.
            if (nameNode && !fileState['duplicateClassNames']?.has(className)) {
              const methodName = nameNode.text;
              
              // Create the unqualified symbol
              const unqualifiedSymbolId = `${file.path}#${methodName}`;
              if (!processedSymbols.has(unqualifiedSymbolId) && !nodes.has(unqualifiedSymbolId)) {
                processedSymbols.add(unqualifiedSymbolId);
                
                // Extract code snippet properly for class members
                let codeSnippet = '';
                if (symbolType === 'field') {
                  // For fields, get the type annotation and initializer
                  const fullText = node.text;
                  const colonIndex = fullText.indexOf(':');
                  if (colonIndex !== -1) {
                    codeSnippet = fullText.substring(colonIndex);
                  }
                } else if (symbolType === 'method') {
                  // For methods, get the signature without the body
                  codeSnippet = node.text?.split('{')[0]?.trim() || '';
                }
                
                nodes.set(unqualifiedSymbolId, {
                  id: unqualifiedSymbolId, type: symbolType, name: methodName, filePath: file.path,
                  startLine: getLineFromIndex(file.content, node.startIndex),
                  endLine: getLineFromIndex(file.content, node.endIndex),
                  codeSnippet,
                });
              }
              
              // Mark the unqualified symbol as processed to prevent duplicate creation
              processedSymbols.add(`${file.path}#${methodName}`);
            }
          }
        }
        return true; // Return true to indicate we handled this symbol completely
      },
      parseParameters: (paramsNode: TSNode, content: string): { name: string; type?: string }[] => {
        const params: { name: string; type?: string }[] = [];
        // For TS, formal_parameters has required_parameter, optional_parameter children.
        for (const child of paramsNode.namedChildren) {
          if (child && (child.type === 'required_parameter' || child.type === 'optional_parameter')) {
            const nameNode = child.childForFieldName('pattern');
            const typeNode = child.childForFieldName('type');
            if (nameNode) {
              params.push({
                name: getNodeText(nameNode, content),
                type: typeNode ? getNodeText(typeNode, content).replace(/^:\s*/, '') : undefined,
              });
            }
          }
        }
        return params;
      },
    };


    const createModuleResolver = (extensions: string[]) => (fromFile: string,
    sourcePath: string, allFiles: string[]): string | null => {
      const basedir = normalizePath(path.dirname(fromFile));
      const importPath = normalizePath(path.join(basedir, sourcePath));

      // Case 1: Path needs an extension or has the wrong one (e.g., .js for .ts)
      const parsedPath = path.parse(importPath);
      const basePath = normalizePath(path.join(parsedPath.dir, parsedPath.name));
      for (const ext of extensions) {
          const potentialFile = basePath + ext;
          if (allFiles.includes(potentialFile)) {
              return potentialFile;
          }
      }
      
      // Case 2: Path is a directory with an index file
      for (const ext of extensions) {
          const potentialIndexFile = normalizePath(path.join(importPath, 'index' + ext));
          if (allFiles.includes(potentialIndexFile)) {
              return potentialIndexFile;
          }
      }

      if (allFiles.includes(importPath)) return importPath;

      return null;      
    };


    const resolveImportFactory = (endings: string[], packageStyle: boolean =
    false) => (fromFile: string, sourcePath: string, allFiles: string[]): string
    | null => {
      const basedir = normalizePath(path.dirname(fromFile));
      const resolvedPathAsIs = normalizePath(path.join(basedir, sourcePath));
      if (allFiles.includes(resolvedPathAsIs)) return resolvedPathAsIs;

      const parsedSourcePath = path.parse(sourcePath);
      const basePath = normalizePath(path.join(basedir, parsedSourcePath.dir, parsedSourcePath.name));
      for (const end of endings) {
        const potentialPath = basePath + end;
        if (allFiles.includes(potentialPath)) return potentialPath;
      }
      
      if (packageStyle && sourcePath.includes('.')) {
        const packagePath = normalizePath(sourcePath.replace(/\./g, '/'));
        for (const end of endings) {
          const fileFromRoot = packagePath + end;
          if (allFiles.includes(fileFromRoot)) return fileFromRoot;
        }
      }
      return null;
    };


    const phpHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'namespace_definition') {
          // For namespace definitions, get the namespace name node
          const nameNode = declarationNode.childForFieldName('name');
          return nameNode;
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const languageHandlers: Record<string, Partial<LanguageHandler>> = {
      default: {
        shouldSkipSymbol: () => false,
        getSymbolNameNode: (declarationNode) => declarationNode.childForFieldName('name'),
        resolveImport: (fromFile, sourcePath, allFiles) => {
          const resolvedPathAsIs = path.normalize(path.join(path.dirname(fromFile), sourcePath));
          return allFiles.includes(resolvedPathAsIs) ? resolvedPathAsIs : null;
        }
      },
      typescript: {
        ...tsLangHandler,
        resolveImport: createModuleResolver(['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs']),
      },
      javascript: {
        resolveImport: createModuleResolver(['.js', '.jsx', '.mjs', '.cjs']),
      },
      tsx: {
        ...tsLangHandler,
        resolveImport: createModuleResolver(['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs']),
      },
      python: { 
        ...pythonHandler, 
        resolveImport: (fromFile: string, sourcePath: string, allFiles: string[]): string | null => {
          const basedir = normalizePath(path.dirname(fromFile));

          // Handle relative imports (starting with .)
          if (sourcePath.startsWith('.')) {
            const dots = sourcePath.match(/^\.+/)?.[0] ?? '';
            const level = dots.length;
            const modulePath = sourcePath.substring(level).replace(/\./g, '/');

            let currentDir = basedir;
            for (let i = 1; i < level; i++) {
              currentDir = path.dirname(currentDir);
            }

            const targetPyFile = normalizePath(path.join(currentDir, modulePath) + '.py');
            if (allFiles.includes(targetPyFile)) return targetPyFile;
            
            const resolvedPath = normalizePath(path.join(currentDir, modulePath, '__init__.py'));
            if (allFiles.includes(resolvedPath)) return resolvedPath;
          }
          
          // Handle absolute imports
          return resolveImportFactory(['.py', '/__init__.py'])(fromFile, sourcePath, allFiles);
        }
      },
      java: { resolveImport: resolveImportFactory(['.java'], true) },
      csharp: { resolveImport: resolveImportFactory(['.cs'], true) },
      php: { ...phpHandler, resolveImport: resolveImportFactory(['.php']) },
      go: goLangHandler,
      rust: {
        ...goLangHandler,
        resolveImport: (fromFile: string, sourcePath: string, allFiles: string[]): string | null => {
          const basedir = normalizePath(path.dirname(fromFile));
          
          // Handle module paths like "utils" -> "utils.rs"
          const resolvedPath = normalizePath(path.join(basedir, sourcePath + '.rs'));
          if (allFiles.includes(resolvedPath)) return resolvedPath;
          
          // Handle mod.rs style imports
          return resolveImportFactory(['.rs', '/mod.rs'])(fromFile, sourcePath, allFiles);
        }
      },
      c: cLangHandler,
      cpp: cLangHandler,
    };


    const getLangHandler = (langName: string): LanguageHandler => ({
      ...languageHandlers['default'],
      ...languageHandlers[langName],
    } as LanguageHandler);



    /**
     * Creates the default Tree-sitter based analyzer. It parses files to find
     * symbols (nodes) and their relationships (edges), constructing a CodeGraph.
     * Supports multiple programming languages.
     * @returns An Analyzer function.
     */
    export const createTreeSitterAnalyzer = (): Analyzer => {
      return async (files: readonly FileContent[]) => {
        const nodes = new Map<string, CodeNode>();
        const edges: CodeEdge[] = [];
        const allFilePaths = files.map(f => normalizePath(f.path));

        // Phase 1: Add all files as nodes
        for (const file of files) {
          const langConfig = getLanguageConfigForFile(normalizePath(file.path));
          nodes.set(file.path, {
            id: file.path, type: 'file', name: path.basename(file.path),
            filePath: file.path, startLine: 1, endLine: file.content.split('\n').length,
            language: langConfig?.name,
          });
        }

        // Phase 2: Group files by language
        const filesByLanguage = files.reduce((acc, file) => {
          const langConfig = getLanguageConfigForFile(normalizePath(file.path));
          if (langConfig) {
            if (!acc.has(langConfig.name)) acc.set(langConfig.name, []);
            acc.get(langConfig.name)!.push(file);
          }
          return acc;
        }, new Map<string, FileContent[]>());

        // Phase 3: Parse all files once
        const fileParseData = new Map<string, { file: FileContent; captures: TSMatch[]; langConfig: LanguageConfig }>();
        for (const [langName, langFiles] of filesByLanguage.entries()) {
          const langConfig = getLanguageConfigForFile(normalizePath(langFiles[0]!.path));
          if (!langConfig) continue;
          try {
            const parser = await createParserForLanguage(langConfig);
            if (!parser.language) continue;
            const query = new (await import('web-tree-sitter')).Query(parser.language, langConfig.query);
            for (const file of langFiles) {
              const tree = parser.parse(file.content);
              if (tree) fileParseData.set(file.path, { file, captures: query.captures(tree.rootNode), langConfig });
            }
          } catch (error) {
            logger.warn(new ParserError(`Failed to process ${langName} files`, langName, error));
            // Continue processing other languages, don't let one language failure stop the entire analysis
            continue;
          }
        }

        // Phase 4: Process definitions for all files
        for (const { file, captures, langConfig } of fileParseData.values()) {
          processFileDefinitions({ nodes }, { ...file, path: normalizePath(file.path) }, captures, langConfig);
        }
        
        // Phase 5: Process relationships for all files
        const resolver = new SymbolResolver(nodes, edges);
        for (const { file, captures, langConfig } of fileParseData.values()) {
          processFileRelationships({ nodes, edges }, { ...file, path: normalizePath(file.path) }, captures, langConfig, resolver, allFilePaths);
        }
        
        // Phase 6: Remove redundant file-level edges when entity-level edges exist
        const entityEdges = new Set<string>();
        for (const edge of edges) {
          if (edge.fromId.includes('#') && edge.toId.includes('#')) {
            // This is an entity-level edge, track the file-level equivalent
            const fromFile = edge.fromId.split('#')[0];
            const toFile = edge.toId.split('#')[0];
            entityEdges.add(`${fromFile}->${toFile}`);
          }
        }
        
        // Remove file-level edges that have corresponding entity-level edges
        const filteredEdges = edges.filter(edge => {
          if (!edge.fromId.includes('#') && edge.toId.includes('#')) {
            // This is a file-to-entity edge, check if there's a corresponding entity-level edge
            const fromFile = edge.fromId;
            const toFile = edge.toId.split('#')[0];
            return !entityEdges.has(`${fromFile}->${toFile}`);
          }
          return true;
        });

        return { nodes: Object.freeze(nodes), edges: Object.freeze(filteredEdges) };
      };
    };


    /**
     * Process symbol definitions for a single file.
     */
    function processFileDefinitions(
      graph: { nodes: Map<string, CodeNode> },
      file: FileContent,
      captures: TSMatch[],
      langConfig: LanguageConfig
    ): void {
      
      const handler = getLangHandler(langConfig.name);
      const fileState = handler.preProcessFile?.(file, captures) || {};
      const processedSymbols = new Set<string>();

      
      const definitionCaptures = captures.filter(({ name }) => name.endsWith('.definition'));
      const otherCaptures = captures.filter(({ name }) => !name.endsWith('.definition'));

      for (const { name, node } of definitionCaptures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const symbolType = getSymbolTypeFromCapture(name, type);
        if (!symbolType) continue;

        const childCaptures = otherCaptures.filter(
          (c) => c.node.startIndex >= node.startIndex && c.node.endIndex <= node.endIndex
        );

        processSymbol(
          { ...graph, file, node, symbolType, processedSymbols, fileState },
          langConfig
    ,
          childCaptures
        );
      }
    }


    /**
     * Process a single symbol definition.
     */
    function processSymbol(
      context: ProcessSymbolContext,
      langConfig: LanguageConfig,
      childCaptures: TSMatch[]
    ): void {
      const { nodes, file, node, symbolType, processedSymbols } = context;
      const handler = getLangHandler(langConfig.name);

      if (handler.shouldSkipSymbol(node, symbolType, langConfig.name)) return;
      if (handler.processComplexSymbol?.(context)) return;

      let declarationNode = node;
      if (node.type === 'export_statement' && node.namedChildCount > 0) {
        declarationNode = node.namedChildren[0] ?? node;
      }
      
      // --- NEW LOGIC TO EXTRACT QUALIFIERS & UI identifiers ---
      const qualifiers: { [key: string]: TSNode } = {};
      for (const capture of childCaptures) {
        qualifiers[capture.name] = capture.node;
      }

      const nameNode = handler.getSymbolNameNode(declarationNode, node) 
        || qualifiers['html.tag'] 
        || qualifiers['css.selector'];

      if (!nameNode) return;

      let symbolName = nameNode.text;
      let symbolId = `${file.path}#${symbolName}`;

      // HTML elements of the same type aren't unique, so we add a line number to the ID.
      if (symbolType === 'html_element') {
        symbolId = `${file.path}#${symbolName}:${nameNode.startPosition.row + 1}`;
      }

      if (symbolName && !processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
        processedSymbols.add(symbolId);

        const visibilityNode = qualifiers['qualifier.visibility'];
        const visibility = visibilityNode
          ? (getNodeText(visibilityNode, file.content) as CodeNodeVisibility)
          : undefined;
        
        const canThrow = childCaptures.some(c => c.name === 'qualifier.throws');
        const isHtmlElement = symbolType === 'html_element';
        const isCssRule = symbolType === 'css_rule';

        const parametersNode = qualifiers['symbol.parameters'];
        const parameters =
          parametersNode && handler.parseParameters
            ? handler.parseParameters(parametersNode, file.content)
            : undefined;

        const returnTypeNode = qualifiers['symbol.returnType'];
        const returnType = returnTypeNode ? getNodeText(returnTypeNode, file.content).replace(/^:\s*/, '') : undefined;

        // Extract code snippet
        let codeSnippet = '';
        if (symbolType === 'variable' || symbolType === 'constant') {
          const fullText = file.content.slice(node.startIndex, node.endIndex);
          const assignmentMatch = fullText.match(/=\s*(.+)$/s);
          if (assignmentMatch) {
            codeSnippet = assignmentMatch[1].trim();
          }
        } else {
          const snippetWithEquals = file.content.slice(nameNode.endIndex, node.endIndex).replace(/^{/, '').trim();
          codeSnippet = snippetWithEquals.startsWith('=') ? snippetWithEquals.substring(1).trim() : snippetWithEquals;
        }

        nodes.set(symbolId, {
          id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
          startLine: getLineFromIndex(file.content, node.startIndex),
          endLine: getLineFromIndex(file.content, node.endIndex),
          codeSnippet,
          ...(qualifiers['qualifier.async'] && { isAsync: true }),
          ...(qualifiers['qualifier.static'] && { isStatic: true }),
          ...(visibility && { visibility }),
          ...(returnType && { returnType }),
          ...(parameters && { parameters }),
          ...(canThrow && { canThrow: true }),
          ...(isHtmlElement && { htmlTag: symbolName }),
          ...(isCssRule && { cssSelector: symbolName }),
        });
      }
    }


    /**
     * Process relationships (imports, calls, inheritance) for a single file.
     */
    function processFileRelationships(
      graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
      file: FileContent,
      captures: TSMatch[],
      langConfig: LanguageConfig,
      resolver: SymbolResolver,
      allFilePaths: string[]
    ): void {
      const handler = getLangHandler(langConfig.name);
      for (const { name, node } of captures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const subtype = parts[parts.length - 1];

        if (type === 'import' && subtype === 'source') {
          const importIdentifier = getNodeText(node, file.content).replace(/['"`]/g, '');
          const importedFilePath = handler.resolveImport(file.path, importIdentifier, allFilePaths);
          if (importedFilePath && graph.nodes.has(importedFilePath)) {
            const edge: CodeEdge = { fromId: file.path, toId: importedFilePath, type: 'imports' };
            if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId)) {
              graph.edges.push(edge);
            }
          }
          continue;
        }

        if (subtype && ['inheritance', 'implementation', 'call', 'reference'].includes(subtype)) {
          const fromId = findEnclosingSymbolId(node, file, graph.nodes);
          if (!fromId) continue;
          const toName = getNodeText(node, file.content).replace(/<.*>$/, '');
          const toNode = resolver.resolve(toName, file.path);
          if (!toNode) continue;
          
          // Skip self-references
          if (fromId === toNode.id) continue;
          
          // Skip references within the same file unless it's a cross-entity reference
          if (fromId.split('#')[0] === toNode.id.split('#')[0] && fromId !== file.path && toNode.id !== file.path) {
            // Only allow cross-entity references within the same file if they're meaningful
            // (e.g., one function calling another, not variable self-references)
            const fromNode = graph.nodes.get(fromId);
            if (fromNode && (fromNode.type === 'variable' || fromNode.type === 'constant') && 
                (toNode.type === 'variable' || toNode.type === 'constant')) {
              continue;
            }
          }
          
          const edgeType = subtype === 'inheritance' ? 'inherits' : 
                          subtype === 'implementation' ? 'implements' : 
                          subtype === 'call' ? 'calls' : 'uses';
          const edge: CodeEdge = { fromId, toId: toNode.id, type: edgeType };
          if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId)) {
            graph.edges.push(edge);
          }
        }
      }
    }


    /**
     * Get symbol type from capture name and language.
     */
    function getSymbolTypeFromCapture(captureName: string, type: string):
    CodeNodeType | null {
      const baseMap = new Map<string, CodeNodeType>([
        ['class', 'class'],
        ['function', 'function'],
        ['function.arrow', 'arrow_function'],
        ['interface', 'interface'],
        ['type', 'type'],
        ['method', 'method'],
        ['field', 'field'],
        ['struct', 'struct'],
        ['enum', 'enum'],
        ['namespace', 'namespace'],
        ['trait', 'trait'],
        ['impl', 'impl'],
        ['constructor', 'constructor'],
        ['property', 'property'],
        ['html.element', 'html_element'],
        ['css.rule', 'css_rule'],
        ['variable', 'variable'],
        ['constant', 'constant'],
        ['static', 'static'],
        ['union', 'union'],
        ['template', 'template'],
      ]);
      return baseMap.get(captureName) ?? baseMap.get(type) ?? null;
    }


    /**
     * A best-effort symbol resolver to find the ID of a referenced symbol.
     */
    class SymbolResolver {
      constructor(
        private nodes: ReadonlyMap<string, CodeNode>,
        private edges: readonly CodeEdge[],
      ) {}

      resolve(symbolName: string, contextFile: string): CodeNode | null {
        const sameFileId = `${contextFile}#${symbolName}`;
        if (this.nodes.has(sameFileId)) return this.nodes.get(sameFileId)!;

        const importedFiles = this.edges.filter(e => e.fromId === contextFile && e.type === 'imports').map(e => e.toId);
        for (const file of importedFiles) {
          const importedId = `${file}#${symbolName}`;
          if (this.nodes.has(importedId)) return this.nodes.get(importedId)!;
        }

        for (const node of this.nodes.values()) {
          if (node.name === symbolName && ['class', 'function', 'interface', 'struct', 'type', 'enum'].includes(node.type)) {
            return node;
          }
        }
        return null;
      }
    }


    /**
     * Traverses up the AST from a start node to find the enclosing symbol definition
     * and returns its unique ID.
     */
    function findEnclosingSymbolId(startNode: TSNode, file: FileContent, nodes:
    ReadonlyMap<string, CodeNode>): string | null {
      let current: TSNode | null = startNode.parent;
      while (current) {
        const nameNode = current.childForFieldName('name');
        if (nameNode) {
          let symbolName = nameNode.text;
          if (current.type === 'method_definition' || (current.type === 'public_field_definition' && !current.text.includes('=>'))) {
            const classNode = current.parent?.parent; // class_body -> class_declaration
            if (classNode?.type === 'class_declaration') {
              symbolName = `${classNode.childForFieldName('name')?.text}.${symbolName}`;
            }
          }
          const symbolId = `${file.path}#${symbolName}`;
          if (nodes.has(symbolId)) return symbolId;
        }
        current = current.parent;
      }
      return file.path; // Fallback to file node
    }
approved: true
