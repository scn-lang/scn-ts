uuid: e7ab4532-a50d-400d-953e-3f5fca5848bb
projectId: scn-ts
createdAt: '2025-07-24T22:43:15.376Z'
linesAdded: 842
linesRemoved: 29
gitCommitMsg: 'feat: add web-demo for browser-based testing and benchmarking'
promptSummary: >-
  Create a web-demo for scn-ts to battle test the library in a browser
  environment, similar to the web-demo in repograph.
reasoning:
  - >-
    Here's my plan to create a web-based demonstration and testing environment
    for `scn-ts`, drawing inspiration from the `repograph` web demo.
  - >-
    1.  **Isomorphic Serializer**: I'll refactor `src/serializer.ts` to be
    "isomorphic," meaning it can run in both Node.js and browser environments.
    This involves removing direct `fs` and `path` dependencies and instead
    passing file content in-memory when in the browser. For Node.js, I'll use
    `eval('require')` as a fallback to dynamically load `fs` and `path`,
    preventing browser bundlers from including them.
  - >-
    2.  **Browser Build Target**: I will introduce a `src/browser.ts` entry
    point and update `tsup.config.ts` to generate a browser-specific bundle
    (`dist/browser.js`). This follows the pattern used by `repograph` and makes
    it easier for bundlers like Vite to use the correct version of the library.
  - >-
    3.  **Enhanced API**: To provide richer data for the web demo, I'll update
    the `generateScn` function in `src/index.ts`. Instead of just returning the
    SCN string, it will now return an object containing both the `scn` string
    and the underlying `RankedCodeGraph` object from `repograph`. This allows
    the UI to display detailed performance metrics like the number of nodes and
    edges found.
  - >-
    4.  **Web Demo Scaffolding**: I will create a new `web-demo` directory
    structured for a Vite + React + TypeScript application. This includes:
  - >-
    *   `package.json` with dependencies like React and a `file:` reference to
    the local `scn-ts` project.
  - >-
    *   `vite.config.ts` with aliases for `scn-ts` and `repograph` to ensure
    their browser builds are used.
  - '*   `tsconfig.json` configured for the web application.'
  - '*   Basic `index.html` and `main.tsx` files.'
  - >-
    5.  **Application UI**: I will implement the main React component,
    `App.tsx`, which will serve as the interactive demo. It will feature:
  - '*   An input area for JSON-formatted file content.'
  - '*   An output area to display the generated SCN map.'
  - '*   Controls to configure the analysis, such as the number of web workers.'
  - >-
    *   A "Worker Battle Test" to benchmark performance with different numbers
    of parallel workers.
  - >-
    *   Panels for real-time logs and performance metric history, similar to the
    `repograph` demo.
  - >-
    This approach will provide a powerful tool for testing, demonstrating, and
    benchmarking `scn-ts` directly in the browser.
  - '---'
  - >-
    First, I'll modify `src/index.ts` to change the return type of `generateScn`
    to include the graph and to pass the file contents to the serializer. This
    is crucial for both browser compatibility and for displaying detailed
    metrics in the web demo.
  - >-
    Next, I'll make `src/serializer.ts` isomorphic by removing direct filesystem
    dependencies and plumbing the in-memory `files` array through the function
    calls.
  - I'll create a new `src/browser.ts` file to serve as the browser entry point.
  - Now, I'll update `tsup.config.ts` to build this new browser entry point.
  - >-
    Next, I'll create the `package.json` for the web demo, defining its
    dependencies and scripts.
  - >-
    Here is the Vite configuration for the web demo, which is critical for
    aliasing to the correct browser builds.
  - I'll add the TypeScript configuration for the web demo.
  - And the `tsconfig.node.json` for Vite's config file.
  - This is the main HTML file for the demo.
  - The CSS styles, adapted from the `repograph` demo.
  - The React entry point, `main.tsx`, which configures `tree-sitter`.
  - >-
    Finally, the heart of the web demo: the `App.tsx` component. It orchestrates
    the analysis, displays results, and manages the UI state.
operations:
  - type: write
    path: src/index.ts
    content: >-
      <<<<<<< SEARCH

      export const generateScn = async (config: ScnTsConfig): Promise<string> =>
      {
        // 1. repograph analyzes the project and returns a structured graph.
        const repoGraphOptions: RepoGraphOptions = {
          root: config.root,
          include: config.include,
          ignore: config.exclude,
          maxWorkers: config.maxWorkers,
          files: config.files,
          // We can set other repograph options here if needed, e.g. rankingStrategy
        };
        const graph: RankedCodeGraph = await analyzeProject(repoGraphOptions);

        // 2. scn-ts serializes that graph into the SCN text format.
        const scnOutput = serializeGraph(graph, config.root);
        return scnOutput;
      };

      =======

      export const generateScn = async (config: ScnTsConfig): Promise<{ scn:
      string; graph: RankedCodeGraph }> => {
        // 1. repograph analyzes the project and returns a structured graph.
        const repoGraphOptions: RepoGraphOptions = {
          root: config.root,
          include: config.include,
          ignore: config.exclude,
          maxWorkers: config.maxWorkers,
          files: config.files,
          // We can set other repograph options here if needed, e.g. rankingStrategy
        };
        const graph: RankedCodeGraph = await analyzeProject(repoGraphOptions);

        // 2. scn-ts serializes that graph into the SCN text format.
        const scnOutput = serializeGraph(graph, config.root, config.files);
        return { scn: scnOutput, graph };
      };

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/serializer.ts
    content: >-
      --- src/serializer.ts

      +++ src/serializer.ts

      @@ -6,8 +6,6 @@
       type CodeEdge = Omit<RepographEdge, 'type'> & {
         type: RepographEdge['type'] | 'contains' | 'references';
       };
      -import { readFileSync } from "fs";

      -import { join } from "path";
       
       type ScnSymbol = "◇" | "~" | "@" | "{}" | "☰" | "=:" | "⛶" | "¶" | "?";
       type QualifierSymbol = "+" | "-" | "..." | "!" | "o";
      @@ -70,22 +68,43 @@
       // Cache for source file contents to avoid reading files multiple times
       const sourceFileCache = new Map<string, string>();
       
      -const getSourceContent = (filePath: string, rootDir?: string): string =>
      {

      -  const fullPath = rootDir ? join(rootDir, filePath) : filePath;

      -  if (!sourceFileCache.has(fullPath)) {

      -    try {

      -      const content = readFileSync(fullPath, 'utf-8');

      -      sourceFileCache.set(fullPath, content);

      -    } catch {

      -      sourceFileCache.set(fullPath, '');

      +const getSourceContent = (

      +  filePath: string,

      +  rootDir?: string,

      +  files?: readonly { path: string; content: string }[]

      +): string => {

      +  // If files are provided in-memory, use them. The cache is
      pre-populated in serializeGraph

      +  if (files) {

      +    return sourceFileCache.get(filePath) || '';

      +  }

      +

      +  // Fallback to filesystem for Node.js environment

      +  // Use eval to prevent bundlers from including 'fs' and 'path' in
      browser builds

      +  if (typeof window === 'undefined') {

      +    try {

      +      const fs = eval("require('fs')");

      +      const path = eval("require('path')");

      +      const fullPath = rootDir ? path.join(rootDir, filePath) : filePath;

      +      if (sourceFileCache.has(fullPath)) {

      +        return sourceFileCache.get(fullPath)!;

      +      }

      +      const content = fs.readFileSync(fullPath, 'utf-8');

      +      sourceFileCache.set(fullPath, content);

      +      return content;

      +    } catch (e) {

      +      sourceFileCache.set(filePath, ''); // cache miss

      +      return '';
           }
         }
      -  return sourceFileCache.get(fullPath) || '';

      +

      +  // In browser without files provided, we can't do anything

      +  return '';
       };
       
      -const getVisibilitySymbol = (node: CodeNode, rootDir?: string): '+' | '-'
      | undefined => {

      +const getVisibilitySymbol = (node: CodeNode, rootDir?: string, files?:
      readonly { path: string; content: string }[]): '+' | '-' | undefined => {
         if (node.visibility === 'public') return '+';
         if (node.visibility === 'private' || node.visibility === 'protected') return '-';
         if (node.type === 'file') return undefined;
       
         // Fallback to source-based inference if repograph doesn't provide visibility.
      -  const source = getSourceContent(node.filePath, rootDir);

      +  const source = getSourceContent(node.filePath, rootDir, files);
         if (!source) return undefined;
         
         const line = (source.split('\n')[node.startLine - 1] || '').trim();
      @@ -118,8 +137,8 @@
         return ENTITY_TYPE_TO_SYMBOL[node.type] ?? '?';
       };
       
      -const getQualifiers = (node: CodeNode, rootDir?: string): { access?: '+'
      | '-'; others: QualifierSymbol[] } => {

      -  const access = getVisibilitySymbol(node, rootDir);

      +const getQualifiers = (node: CodeNode, rootDir?: string, files?: readonly
      { path: string; content: string }[]): { access?: '+' | '-'; others:
      QualifierSymbol[] } => {

      +  const access = getVisibilitySymbol(node, rootDir, files);
         
         const others: QualifierSymbol[] = [];
         
      @@ -131,16 +150,16 @@
         if (canThrow) others.push('!');
         
         // Check for pure function heuristic
      -  const isPure = node.isPure || isPureFunction(node, rootDir);

      +  const isPure = node.isPure || isPureFunction(node, rootDir, files);
         if (isPure) others.push('o');
         
         return { access, others };
       };
       
      -const isPureFunction = (node: CodeNode, rootDir?: string): boolean => {

      +const isPureFunction = (node: CodeNode, rootDir?: string, files?:
      readonly { path: string; content: string }[]): boolean => {
         if (!['function', 'method', 'arrow_function'].includes(node.type)) return false;
         if (!node.codeSnippet) return false;
         
         // Get the full source to analyze the function body
      -  const source = getSourceContent(node.filePath, rootDir);

      +  const source = getSourceContent(node.filePath, rootDir, files);
         if (!source) return false;
         
         const lines = source.split('\n');
      @@ -216,11 +235,11 @@
           return attrs.length > 0 ? `[ ${attrs.join(' ')} ]` : '';
       }
       
      -const formatSignature = (node: CodeNode, rootDir?: string): string => {

      +const formatSignature = (node: CodeNode, rootDir?: string, files?:
      readonly { path: string; content: string }[]): string => {
         if (isComponentNode(node)) {
           // For components, we need to extract props from the full function signature
           // Get the source content to find the complete function definition
      -    const source = getSourceContent(node.filePath, rootDir);

      +    const source = getSourceContent(node.filePath, rootDir, files);
           if (source) {
             const lines = source.split('\n');
             const startLine = node.startLine - 1;
      @@ -292,10 +311,10 @@
         return '';
       };
       
      -const formatNode = (node: CodeNode, graph: RankedCodeGraph, idManager:
      ScnIdManager, rootDir?: string, level = 0): string => {

      +const formatNode = (node: CodeNode, graph: RankedCodeGraph, idManager:
      ScnIdManager, rootDir?: string, level = 0, files?: readonly { path:
      string; content: string }[]): string => {
         const symbol = getNodeSymbol(node);
      -  const { access, others } = getQualifiers(node, rootDir);

      -  const signature = formatSignature(node, rootDir);

      +  const { access, others } = getQualifiers(node, rootDir, files);

      +  const signature = formatSignature(node, rootDir, files);
         const scnId = idManager.getScnId(node.id);
         const id = scnId ? `(${scnId})` : '';
         const indent = '  '.repeat(level + 1);
      @@ -359,7 +378,8 @@
         symbols: CodeNode[],
         graph: RankedCodeGraph,
         idManager: ScnIdManager,
      -  rootDir?: string

      +  rootDir?: string,

      +  files?: readonly { path: string; content: string }[]
       ): string => {
         const scnId = idManager.getScnId(fileNode.id) ?? '';
       
      @@ -440,8 +460,8 @@
       
         const nodeLines: string[] = [];
         const processNode = (wrapper: {node: CodeNode, children: any[]}, level: number) => {
      -    nodeLines.push(formatNode(wrapper.node, graph, idManager, rootDir,
      level));

      +    nodeLines.push(formatNode(wrapper.node, graph, idManager, rootDir,
      level, files));
           for (const childWrapper of wrapper.children) {
             processNode(childWrapper, level + 1);
           }
      @@ -462,7 +482,15 @@
        * @param rootDir - The root directory of the project (for reading source files).
        * @returns A string containing the full SCN map.
        */
      -export const serializeGraph = (graph: RankedCodeGraph, rootDir?: string):
      string => {

      +export const serializeGraph = (graph: RankedCodeGraph, rootDir?: string,
      files?: readonly { path: string; content: string }[]): string => {

      +  // Clear and pre-populate source file cache if files are provided
      in-memory

      +  sourceFileCache.clear();

      +  if (files) {

      +    for (const file of files) {

      +      sourceFileCache.set(file.path, file.content);

      +    }

      +  }

      +
         const nodesByFile = new Map<string, CodeNode[]>(); // filePath -> nodes
         const fileNodes: CodeNode[] = [];
       
      @@ -484,7 +512,7 @@
           const symbols = nodesByFile.get(fileNode.filePath) || [];
           // Sort symbols by line number to ensure deterministic output for hierarchical processing
           symbols.sort((a,b) => a.startLine - b.startLine);
      -    return serializeFile(fileNode, symbols, graph, idManager, rootDir);

      +    return serializeFile(fileNode, symbols, graph, idManager, rootDir,
      files);
         });
       
         return scnParts.join('\n\n');
    patchStrategy: new-unified
  - type: write
    path: src/browser.ts
    content: export * from './index';
    patchStrategy: replace
  - type: write
    path: tsup.config.ts
    content: |-
      <<<<<<< SEARCH
          entry: ['src/index.ts'],
      =======
          entry: ['src/index.ts', 'src/browser.ts'],
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: web-demo/package.json
    content: |-
      {
        "name": "scn-ts-web-demo",
        "private": true,
        "version": "0.0.0",
        "type": "module",
        "scripts": {
          "dev": "vite",
          "build": "tsc && vite build",
          "preview": "vite preview",
          "get-wasm": "scn-ts copy-wasm ./public/wasm"
        },
        "dependencies": {
          "react": "^18.2.0",
          "react-dom": "^18.2.0",
          "react-markdown": "^9.0.1",
          "react-syntax-highlighter": "^15.5.0",
          "remark-gfm": "^4.0.0",
          "scn-ts": "file:..",
          "repograph": "^0.1.19"
        },
        "devDependencies": {
          "@types/react": "^18.2.66",
          "@types/react-dom": "^18.2.22",
          "@types/react-syntax-highlighter": "^15.5.13",
          "@vitejs/plugin-react": "^4.2.1",
          "typescript": "^5.2.2",
          "vite": "^5.2.0"
        }
      }
    patchStrategy: replace
  - type: write
    path: web-demo/vite.config.ts
    content: |-
      import { defineConfig } from 'vite'
      import react from '@vitejs/plugin-react'
      import path from 'path'

      // https://vitejs.dev/config/
      export default defineConfig({
        plugins: [
          react(),
        ],
        optimizeDeps: {
          exclude: ['scn-ts', 'repograph', 'web-tree-sitter']
        },
        resolve: {
          alias: {
            'scn-ts': path.resolve(__dirname, '../dist/browser.js'),
            // When scn-ts imports 'repograph', we need to give it the browser version.
            'repograph': path.resolve(__dirname, '../node_modules/repograph/dist/browser.js')
          }
        },
        define: {
          global: 'globalThis',
          'process.env': {},
          'process.platform': '"browser"',
          'process.version': '"v18.0.0"'
        },
        server: {
          fs: {
            // Allow serving files from one level up (the project root)
            allow: ['..']
          },
          headers: {
            'Cross-Origin-Embedder-Policy': 'require-corp',
            'Cross-Origin-Opener-Policy': 'same-origin',
          }
        },
        worker: {
          plugins: () => []
        },
        assetsInclude: ['**/*.wasm'],
        publicDir: 'public'
      })
    patchStrategy: replace
  - type: write
    path: web-demo/tsconfig.json
    content: |-
      {
        "compilerOptions": {
          "target": "ES2020",
          "useDefineForClassFields": true,
          "lib": ["ES2020", "DOM", "DOM.Iterable"],
          "module": "ESNext",
          "skipLibCheck": true,

          // Path mapping for local development
          "baseUrl": ".",
          "paths": {
            "scn-ts": ["../src/browser.ts"],
            "repograph": ["../node_modules/repograph/dist/index.d.ts"]
          },

          /* Bundler mode */
          "moduleResolution": "bundler",
          "allowImportingTsExtensions": true,
          "resolveJsonModule": true,
          "isolatedModules": true,
          "noEmit": true,
          "jsx": "react-jsx",

          /* Linting */
          "strict": true,
          "noUnusedLocals": true,
          "noUnusedParameters": true,
          "noFallthroughCasesInSwitch": true
        },
        "include": ["src"],
        "references": [{ "path": "./tsconfig.node.json" }]
      }
    patchStrategy: replace
  - type: write
    path: web-demo/tsconfig.node.json
    content: |-
      {
        "compilerOptions": {
          "composite": true,
          "skipLibCheck": true,
          "module": "ESNext",
          "moduleResolution": "bundler",
          "allowSyntheticDefaultImports": true
        },
        "include": ["vite.config.ts"]
      }
    patchStrategy: replace
  - type: write
    path: web-demo/index.html
    content: |-
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="UTF-8" />
          <link rel="icon" type="image/svg+xml" href="/vite.svg" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>SCN-TS Web Demo</title>
        </head>
        <body>
          <div id="root"></div>
          <script type="module" src="/src/main.tsx"></script>
        </body>
      </html>
    patchStrategy: replace
  - type: write
    path: web-demo/src/App.css
    content: |-
      :root {
        font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
        line-height: 1.5;
        font-weight: 400;

        color-scheme: light dark;
        color: rgba(255, 255, 255, 0.87);
        background-color: #242424;

        font-synthesis: none;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      body {
        margin: 0;
        display: flex;
        place-items: center;
        min-width: 320px;
        min-height: 100vh;
      }

      #root {
        max-width: 1400px;
        margin: 0 auto;
        padding: 1rem;
        width: 100%;
      }

      h1 {
        font-size: 2.2em;
        line-height: 1.1;
        margin-block-start: 0;
        margin-bottom: 1rem;
        text-align: center;
      }

      .main-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        height: calc(100vh - 6rem);
      }

      .config-panel {
        background-color: #1e1e1e;
        border: 1px solid #444;
        border-radius: 8px;
        padding: 1rem;
        flex-shrink: 0;
      }

      .config-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .config-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9em;
      }

      .config-item input[type="number"] {
        width: 60px;
        padding: 0.25rem;
        background-color: #2a2a2a;
        border: 1px solid #555;
        border-radius: 4px;
        color: #d4d4d4;
      }

      .config-item input[type="checkbox"] {
        accent-color: #646cff;
      }

      .config-info {
        grid-column: 1 / -1;
        padding: 0.75rem;
        background-color: #2a2a2a;
        border-radius: 4px;
        font-size: 0.9em;
        border-left: 3px solid #646cff;
      }

      .action-buttons {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .primary-button {
        background-color: #646cff;
        color: white;
        border: none;
      }

      .primary-button:hover:not(:disabled) {
        background-color: #5a5fcf;
      }

      .secondary-button {
        background-color: #2a2a2a;
        border: 1px solid #555;
      }

      .secondary-button:hover:not(:disabled) {
        border-color: #777;
      }

      .current-metrics {
        margin-top: 1rem;
        padding: 1rem;
        background-color: #2a2a2a;
        border-radius: 6px;
      }

      .current-metrics h4 {
        margin: 0 0 0.5rem 0;
        color: #60a5fa;
      }

      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 0.5rem;
        font-size: 0.85em;
        font-family: monospace;
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        flex: 1;
        min-height: 0;
      }

      .bottom-panels {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 1rem;
        height: 300px;
        flex-shrink: 0;
      }

      .panel {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        overflow: hidden;
      }

      textarea {
        width: 100%;
        height: 100%;
        resize: none;
        background-color: #1e1e1e;
        border: 1px solid #444;
        border-radius: 8px;
        color: #d4d4d4;
        font-family: monospace;
        font-size: 14px;
        padding: 1rem;
        box-sizing: border-box;
      }

      button {
        border-radius: 8px;
        border: 1px solid transparent;
        padding: 0.6em 1.2em;
        font-size: 1em;
        font-weight: 500;
        font-family: inherit;
        background-color: #1a1a1a;
        cursor: pointer;
        transition: border-color 0.25s;
      }
      button:hover {
        border-color: #646cff;
      }
      button:disabled {
          cursor: not-allowed;
          opacity: 0.5;
      }

      .output-panel, .logs-panel {
        border: 1px solid #444;
        border-radius: 8px;
        padding: 1rem;
        overflow-y: auto;
        background-color: #1e1e1e;
      }

      .output-panel pre {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: monospace;
        font-size: 14px;
      }

      .logs-panel {
          height: 100%;
          flex-shrink: 0;
      }

      .log-entry {
        font-family: monospace;
        white-space: pre-wrap;
        word-break: break-all;
        padding: 2px 4px;
        border-radius: 4px;
        display: flex;
        gap: 0.5rem;
        font-size: 0.8em;
      }

      .log-timestamp {
        color: #888;
        flex-shrink: 0;
      }

      .log-level {
        flex-shrink: 0;
        font-weight: bold;
      }

      .log-message {
        flex: 1;
      }

      .log-error { color: #f87171; background-color: #450a0a; }
      .log-warn { color: #facc15; background-color: #422006; }
      .log-info { color: #60a5fa; }
      .log-debug { color: #888; }

      .metrics-history {
        height: 100%;
        overflow-y: auto;
      }

      .metrics-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8em;
        font-family: monospace;
      }

      .metrics-table th,
      .metrics-table td {
        padding: 0.5rem;
        text-align: left;
        border-bottom: 1px solid #444;
      }

      .metrics-table th {
        background-color: #2a2a2a;
        font-weight: bold;
        position: sticky;
        top: 0;
      }

      .metrics-table tr.latest {
        background-color: #2a2a2a;
        font-weight: bold;
      }

      .metrics-table tr:hover {
        background-color: #333;
      }

      pre {
          background-color: #2d2d2d !important;
          border-radius: 4px;
          padding: 1em !important;
      }
    patchStrategy: replace
  - type: write
    path: web-demo/src/main.tsx
    content: |-
      // Configure web-tree-sitter before any other imports
      (window as any).TreeSitterModule = {
        locateFile: (path: string) => {
          if (path === 'tree-sitter.wasm') {
            return '/tree-sitter.wasm';
          }
          return path;
        }
      };

      import React from 'react'
      import ReactDOM from 'react-dom/client'
      import App from './App'
      import './App.css'

      ReactDOM.createRoot(document.getElementById('root')!).render(
        <React.StrictMode>
          <App />
        </React.StrictMode>,
      )
    patchStrategy: replace
  - type: write
    path: web-demo/src/App.tsx
    content: >-
      import { useState, useEffect, useCallback, useRef, type FC } from 'react';

      import {
        generateScn,
        initializeParser,
        logger,
        type FileContent,
        type LogLevel,
        type RankedCodeGraph,
      } from 'scn-ts';

      import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';

      import { vscDarkPlus } from
      'react-syntax-highlighter/dist/esm/styles/prism';


      import './App.css';


      const defaultInput = JSON.stringify(
        [
          {
            path: 'src/components/Button.tsx',
            content: `import React from 'react';\nimport { styled } from '../styles';\nimport { useApi } from '../hooks/useApi';\n\ninterface ButtonProps {\n  onClick?: () => void;\n  children: React.ReactNode;\n  variant?: 'primary' | 'secondary';\n}\n\nexport const Button: React.FC<ButtonProps> = ({ onClick, children, variant = 'primary' }) => {\n  const { isLoading } = useApi();\n  \n  return (\n    <StyledButton \n      onClick={onClick} \n      disabled={isLoading}\n      className={\`btn btn-\${variant}\`}\n    >\n      {children}\n    </StyledButton>\n  );\n};\n\nconst StyledButton = styled.button\`\n  padding: 0.5rem 1rem;\n  border-radius: 4px;\n  border: none;\n  cursor: pointer;\n  \n  &.btn-primary {\n    background-color: #007bff;\n    color: white;\n  }\n  \n  &.btn-secondary {\n    background-color: #6c757d;\n    color: white;\n  }\n  \n  &:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n\`;`,
          },
          {
            path: 'src/hooks/useApi.ts',
            content: `import { useState, useEffect, useCallback } from 'react';\nimport { ApiClient } from '../api/client';\n\nconst apiClient = new ApiClient();\n\nexport interface UseApiState<T> {\n  data: T | null;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport function useApi<T>() {\n  const [state, setState] = useState<UseApiState<T>>({\n    data: null,\n    isLoading: false,\n    error: null,\n  });\n\n  const execute = useCallback(async (apiCall: () => Promise<T>) => {\n    setState(prev => ({ ...prev, isLoading: true, error: null }));\n    \n    try {\n      const result = await apiCall();\n      setState({ data: result, isLoading: false, error: null });\n      return result;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'An error occurred';\n      setState({ data: null, isLoading: false, error: errorMessage });\n      throw error;\n    }\n  }, []);\n\n  return {\n    ...state,\n    execute,\n    client: apiClient,\n  };\n}`
          },
        ],
        null,
        2
      );


      type LogEntry = {
        level: LogLevel | 'log';
        args: any[];
        timestamp: number;
      }


      type PerformanceMetrics = {
        startTime: number;
        endTime: number;
        duration: number;
        filesProcessed: number;
        nodesFound: number;
        edgesFound: number;
        maxWorkers: number;
        workerMode: 'sequential' | 'worker' | 'web-worker';
      }


      type WorkerConfig = {
        maxWorkers: number;
        stressTestEnabled: boolean;
        stressTestMultiplier: number;
      }


      function App() {
        const [input, setInput] = useState(defaultInput);
        const [output, setOutput] = useState('');
        const [logs, setLogs] = useState<LogEntry[]>([]);
        const [isAnalyzing, setIsAnalyzing] = useState(false);
        const [workerConfig, setWorkerConfig] = useState<WorkerConfig>({
          maxWorkers: 1,
          stressTestEnabled: false,
          stressTestMultiplier: 1,
        });
        const [performanceMetrics, setPerformanceMetrics] = useState<PerformanceMetrics[]>([]);
        const [currentMetrics, setCurrentMetrics] = useState<PerformanceMetrics | null>(null);
        const abortControllerRef = useRef<AbortController | null>(null);
        
        useEffect(() => {
          logger.setLevel('debug');

          const originalConsole = { ...console };
          const intercept = (level: LogLevel | 'log', ...args: any[]) => {
            (originalConsole as any)[level](...args);
            setLogs(prev => [...prev, { level, args, timestamp: Date.now() }]);
          };

          console.log = (...args) => intercept('log', ...args);
          console.info = (...args) => intercept('info', ...args);
          console.warn = (...args) => intercept('warn', ...args);
          console.error = (...args) => intercept('error', ...args);
          console.debug = (...args) => intercept('debug', ...args);

          return () => {
            Object.assign(console, originalConsole);
          };
        }, []);

        const handleAnalyze = useCallback(async () => {
          if (abortControllerRef.current) {
            abortControllerRef.current.abort();
          }
          
          abortControllerRef.current = new AbortController();
          
          setIsAnalyzing(true);
          setOutput('');
          setLogs([]);
          
          const startTime = performance.now();
          console.info('Starting SCN generation...', { workerConfig });

          try {
            let files: FileContent[] = JSON.parse(input);
            if (!Array.isArray(files) || !files.every(f => f.path && typeof f.content === 'string')) {
                throw new Error('Invalid input format. Must be an array of {path: string, content: string}');
            }

            // Apply stress test multiplier if enabled
            if (workerConfig.stressTestEnabled && workerConfig.stressTestMultiplier > 1) {
              const originalFiles = [...files];
              files = [];
              for (let i = 0; i < workerConfig.stressTestMultiplier; i++) {
                const multipliedFiles = originalFiles.map(f => ({
                  ...f,
                  path: `stress-${i}/${f.path}`,
                }));
                files.push(...multipliedFiles);
              }
              console.info(`Stress test enabled: multiplied ${originalFiles.length} files by ${workerConfig.stressTestMultiplier} = ${files.length} total files`);
            }
            
            console.info('Initializing parser...');
            await initializeParser({ wasmBaseUrl: '/wasm/' });
            console.info('Parser initialized.');

            const maxWorkers = workerConfig.maxWorkers;
            const workerMode = maxWorkers > 1 ? 'web-worker' : 'sequential';

            console.info(`Generating SCN for ${files.length} files with ${maxWorkers} workers (mode: ${workerMode})...`);
            
            const analysisStartTime = performance.now();
            const { scn, graph } = await generateScn({
              files,
              maxWorkers,
            });
            const analysisEndTime = performance.now();
            
            setOutput(scn);
            console.info('SCN generation complete.');

            const endTime = performance.now();
            const metrics: PerformanceMetrics = {
              startTime,
              endTime,
              duration: endTime - startTime,
              filesProcessed: files.length,
              nodesFound: graph.nodes.size,
              edgesFound: graph.edges.length,
              maxWorkers,
              workerMode,
            };
            
            setCurrentMetrics(metrics);
            setPerformanceMetrics(prev => [...prev, metrics]);
            
            console.info('Performance metrics:', {
              totalDuration: `${metrics.duration.toFixed(2)}ms`,
              analysisDuration: `${(analysisEndTime - analysisStartTime).toFixed(2)}ms`,
            });

          } catch (e: any) {
            console.error('Generation failed:', e.message, e);
            setOutput(`# Generation Failed\n\n**Error:**\n\`\`\`\n${e.stack || e.message}\n\`\`\``);
          } finally {
            setIsAnalyzing(false);
            abortControllerRef.current = null;
          }
        }, [input, workerConfig]);

        const handleCancel = useCallback(() => {
          if (abortControllerRef.current) {
            abortControllerRef.current.abort();
          }
        }, []);

        const handleClearMetrics = useCallback(() => {
          setPerformanceMetrics([]);
          setCurrentMetrics(null);
        }, []);

        const handleRunBenchmark = useCallback(async () => {
          const workerCounts = [1, 2, 4, 8];
          const originalConfig = { ...workerConfig };

          for (const maxWorkers of workerCounts) {
            if (abortControllerRef.current?.signal.aborted) break;
            
            setWorkerConfig(prev => ({ ...prev, maxWorkers }));
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            await handleAnalyze();
            await new Promise(resolve => setTimeout(resolve, 500)); // Pause between runs
          }
          
          // Restore original config
          setWorkerConfig(originalConfig);
        }, [workerConfig, handleAnalyze]);

        return (
          <>
            <h1>SCN-TS Web Demo - Worker Battle Test</h1>
            <div className="main-container">
              <div className="config-panel">
                <h3>SCN-TS Worker Battle Test Configuration</h3>
                <div className="config-grid">
                  <label className="config-item">
                    Max Workers:
                    <input
                      type="number"
                      min="1"
                      max="8"
                      value={workerConfig.maxWorkers}
                      onChange={e => setWorkerConfig(prev => ({ ...prev, maxWorkers: parseInt(e.target.value) || 1 }))}
                      title="Number of worker threads for parallel analysis (1 = sequential)"
                    />
                  </label>
                  
                  <label className="config-item">
                    <input
                      type="checkbox"
                      checked={workerConfig.stressTestEnabled}
                      onChange={e => setWorkerConfig(prev => ({ ...prev, stressTestEnabled: e.target.checked }))}
                    />
                    Stress Test Mode
                  </label>
                  
                  <label className="config-item">
                    File Multiplier:
                    <input
                      type="number"
                      min="1"
                      max="20"
                      value={workerConfig.stressTestMultiplier}
                      onChange={e => setWorkerConfig(prev => ({ ...prev, stressTestMultiplier: parseInt(e.target.value) || 1 }))}
                      disabled={!workerConfig.stressTestEnabled}
                      title="Multiply input files by this factor for stress testing"
                    />
                  </label>
                  
                  <div className="config-info">
                    <strong>Current Mode:</strong> {workerConfig.maxWorkers > 1 ? `Parallel (${workerConfig.maxWorkers} workers)` : 'Sequential'}
                    {workerConfig.stressTestEnabled && (
                      <span> | Stress Test: {workerConfig.stressTestMultiplier}x files</span>
                    )}
                  </div>
                </div>
                
                <div className="action-buttons">
                  <button onClick={handleAnalyze} disabled={isAnalyzing} className="primary-button">
                    {isAnalyzing ? 'Generating...' : 'Generate SCN'}
                  </button>
                  <button onClick={handleCancel} disabled={!isAnalyzing} className="secondary-button">
                    Cancel
                  </button>
                  <button onClick={handleRunBenchmark} disabled={isAnalyzing} className="secondary-button">
                    Run Worker Benchmark (1,2,4,8 workers)
                  </button>
                  <button onClick={handleClearMetrics} className="secondary-button">
                    Clear Metrics
                  </button>
                </div>
                
                {currentMetrics && (
                  <div className="current-metrics">
                    <h4>Last Run Metrics</h4>
                    <div className="metrics-grid">
                      <span>Duration: {currentMetrics.duration.toFixed(2)}ms</span>
                      <span>Files: {currentMetrics.filesProcessed}</span>
                      <span>Nodes: {currentMetrics.nodesFound}</span>
                      <span>Edges: {currentMetrics.edgesFound}</span>
                      <span>Workers: {currentMetrics.maxWorkers}</span>
                      <span>Mode: {currentMetrics.workerMode}</span>
                      <span>Files/sec: {(currentMetrics.filesProcessed / (currentMetrics.duration / 1000)).toFixed(2)}</span>
                      <span>Nodes/sec: {(currentMetrics.nodesFound / (currentMetrics.duration / 1000)).toFixed(2)}</span>
                    </div>
                  </div>
                )}
              </div>
              
              <div className="container">
                <div className="panel">
                    <h3>Input Files (JSON format)</h3>
                    <textarea
                        value={input}
                        onChange={e => setInput(e.target.value)}
                        placeholder="Enter FileContent[] as JSON string..."
                        spellCheck="false"
                    />
                </div>
                <div className="panel">
                    <h3>Output SCN</h3>
                    <div className="output-panel">
                      <SyntaxHighlighter
                        language="swift" // Using a language with similar comment/symbol syntax for basic highlighting
                        style={vscDarkPlus as any}
                        PreTag="pre"
                      >
                        {output}
                      </SyntaxHighlighter>
                    </div>
                </div>
              </div>
              
              <div className="bottom-panels">
                <div className="panel">
                  <h3>Performance History</h3>
                  <div className="metrics-history">
                    {performanceMetrics.length === 0 ? (
                      <p>No metrics yet. Run an analysis to see performance data.</p>
                    ) : (
                      <table className="metrics-table">
                        <thead>
                          <tr>
                            <th>Run</th>
                            <th>Mode</th>
                            <th>Workers</th>
                            <th>Files</th>
                            <th>Duration (ms)</th>
                            <th>Nodes</th>
                            <th>Files/sec</th>
                            <th>Nodes/sec</th>
                          </tr>
                        </thead>
                        <tbody>
                          {performanceMetrics.map((metric, i) => (
                            <tr key={i} className={i === performanceMetrics.length - 1 ? 'latest' : ''}>
                              <td>{i + 1}</td>
                              <td>{metric.workerMode}</td>
                              <td>{metric.maxWorkers}</td>
                              <td>{metric.filesProcessed}</td>
                              <td>{metric.duration.toFixed(2)}</td>
                              <td>{metric.nodesFound}</td>
                              <td>{(metric.filesProcessed / (metric.duration / 1000)).toFixed(2)}</td>
                              <td>{(metric.nodesFound / (metric.duration / 1000)).toFixed(2)}</td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    )}
                  </div>
                </div>
                
                <div className="panel">
                    <h3>Logs</h3>
                    <div className="logs-panel">
                        {logs.map((log, i) => (
                            <div key={i} className={`log-entry log-${log.level}`}>
                                <span className="log-timestamp">{new Date(log.timestamp).toLocaleTimeString()}</span>
                                <span className="log-level">[{log.level.toUpperCase()}]</span>
                                <span className="log-message">{log.args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ')}</span>
                            </div>
                        ))}
                    </div>
                </div>
              </div>
            </div>
          </>
        );
      }


      export default App;
    patchStrategy: replace
snapshot:
  src/browser.ts: null
  web-demo/package.json: null
  web-demo/vite.config.ts: null
  web-demo/tsconfig.json: null
  web-demo/tsconfig.node.json: null
  web-demo/index.html: null
  web-demo/src/App.css: null
  web-demo/src/main.tsx: null
  web-demo/src/App.tsx: null
  tsup.config.ts: |-
    import { defineConfig } from 'tsup';

    export default defineConfig([
      {
        entry: ['src/index.ts'],
        format: ['cjs', 'esm'],
        dts: true,
        sourcemap: true,
        clean: true, // Cleans the dist folder once before building.
        splitting: false,
        shims: true,
        external: ['repograph'],
      },
      {
        entry: ['src/cli.ts'],
        format: ['cjs', 'esm'],
        sourcemap: true,
        splitting: false,
        shims: true,
        external: ['repograph'],
        banner: {
          js: '#!/usr/bin/env node',
        },
        // No .d.ts files for the CLI entry point.
      },
    ]);
  src/index.ts: |-
    import { analyzeProject } from 'repograph';
    import type { RankedCodeGraph, RepoGraphOptions } from 'repograph';
    import { serializeGraph } from './serializer';

    export interface ScnTsConfig {
      /**
       * The root directory of the project to analyze. Defaults to the current working directory.
       * Not used if `files` is provided.
       */
      root?: string;
      /**
       * Glob patterns for files to include. Required if `files` is not provided.
       */
      include?: string[];
      /** Glob patterns for files to exclude. */
      exclude?: string[];
      /**
       * For browser or in-memory usage, provide file contents directly. This will
       * bypass all file-system operations (`root`, `include`, `exclude`).
       */
      files?: readonly { path: string; content: string }[];
      /** Path to the project's tsconfig.json. (Not currently used by repograph) */
      project?: string;
      /**
       * The maximum number of parallel workers to use for analysis.
       * When set to 1, analysis runs in the main thread without workers.
       * For faster test execution, use higher values (e.g., 4-8).
       * @default 1
       */
      maxWorkers?: number;
      /** (Future) An array of language parser plugins. */
      // plugins?: unknown[];
    }

    /**
     * High-level API to generate an SCN context map from a project.
     *
     * This function orchestrates the entire process:
     * 1. Invokes `repograph` to analyze the codebase and build a `RankedCodeGraph`.
     * 2. Serializes the resulting graph into the SCN text format.
     *
     * @param config - The configuration specifying which files to analyze.
     * @returns A promise that resolves to the SCN map as a string.
     */
    export const generateScn = async (config: ScnTsConfig): Promise<string> => {
      // 1. repograph analyzes the project and returns a structured graph.
      const repoGraphOptions: RepoGraphOptions = {
        root: config.root,
        include: config.include,
        ignore: config.exclude,
        maxWorkers: config.maxWorkers,
        files: config.files,
        // We can set other repograph options here if needed, e.g. rankingStrategy
      };
      const graph: RankedCodeGraph = await analyzeProject(repoGraphOptions);

      // 2. scn-ts serializes that graph into the SCN text format.
      const scnOutput = serializeGraph(graph, config.root);
      return scnOutput;
    };

    // Low-level API for composition
    export { serializeGraph };

    // Re-export from repograph for advanced users
    export {
      // High-Level API
      analyzeProject,
      generateMap,
      // Low-Level API
      createMapGenerator,
      // Pipeline component factories
      createDefaultDiscoverer,
      createTreeSitterAnalyzer,
      createPageRanker,
      createGitRanker,
      createMarkdownRenderer,
      // Logger utilities
      logger,
      initializeParser,
    } from 'repograph';

    // Re-export types from repograph
    export type {
      // Core types
      FileContent,
      CodeNode,
      CodeNodeType,
      CodeNodeVisibility,
      CodeEdge,
      CodeGraph,
      RankedCodeGraph,
      RepoGraphMap,
      RepoGraphOptions,
      RendererOptions,
      FileDiscoverer,
      CssIntent,
      Analyzer,
      Ranker,
      Renderer,
      // Logger types
      Logger,
      LogLevel,
      // Parser types
      ParserInitializationOptions,
    } from 'repograph';
  src/serializer.ts: >-
    import type {
      RankedCodeGraph,
      CodeNode,
      CodeEdge as RepographEdge,
      CssIntent,
      CodeNodeType,
    } from "repograph";


    // Allow for 'contains' and 'references' edges which might be produced by
    repograph

    // but not present in a minimal type definition.

    type CodeEdge = Omit<RepographEdge, 'type'> & {
      type: RepographEdge['type'] | 'contains' | 'references';
    };

    import { readFileSync } from "fs";

    import { join } from "path";


    type ScnSymbol = "◇" | "~" | "@" | "{}" | "☰" | "=:" | "⛶" | "¶" | "?";

    type QualifierSymbol = "+" | "-" | "..." | "!" | "o";

    type CssIntentSymbol = "📐" | "✍" | "💧";


    const ENTITY_TYPE_TO_SYMBOL: Record<CodeNodeType, ScnSymbol | undefined> = {
      class: '◇',
      function: '~',
      method: '~',
      interface: '{}',
      enum: '☰',
      type: '=:',
      html_element: '⛶',
      css_rule: '¶',
      namespace: '◇',
      struct: '◇',
      property: '@',
      field: '@',
      variable: '@',
      constant: '@',
      arrow_function: '~',
      constructor: '~',
      file: undefined,
      trait: undefined,
      impl: undefined,
      static: undefined,
      union: undefined,
      template: undefined,
    };


    const CSS_INTENT_TO_SYMBOL: Record<CssIntent, CssIntentSymbol> = {
      layout: '📐',
      typography: '✍',
      appearance: '💧',
    };


    class ScnIdManager {
      private fileIdCounter = 1;
      private entityIdCounters = new Map<string, number>(); // file path -> counter
      private repographIdToScnId = new Map<string, string>();
      private fileRepoIdToPath = new Map<string, string>();

      constructor(sortedFileNodes: CodeNode[], nodesByFile: Map<string, CodeNode[]>) {
        for (const fileNode of sortedFileNodes) {
          const fileId = `${this.fileIdCounter++}`;
          this.repographIdToScnId.set(fileNode.id, fileId);
          this.fileRepoIdToPath.set(fileNode.id, fileNode.filePath);
          this.entityIdCounters.set(fileNode.filePath, 1);

          const entities = nodesByFile.get(fileNode.filePath) || [];
          entities.sort((a, b) => a.startLine - b.startLine);

          for (const entityNode of entities) {
            const entityCounter = this.entityIdCounters.get(entityNode.filePath)!;
            const entityId = `${fileId}.${entityCounter}`;
            this.repographIdToScnId.set(entityNode.id, entityId);
            this.entityIdCounters.set(entityNode.filePath, entityCounter + 1);
          }
        }
      }

      getScnId(repographId: string): string | undefined {
        return this.repographIdToScnId.get(repographId);
      }

      isFilePath(repographId: string): boolean {
        return this.fileRepoIdToPath.has(repographId);
      }
    }


    // Cache for source file contents to avoid reading files multiple times

    const sourceFileCache = new Map<string, string>();


    const getSourceContent = (filePath: string, rootDir?: string): string => {
      const fullPath = rootDir ? join(rootDir, filePath) : filePath;
      if (!sourceFileCache.has(fullPath)) {
        try {
          const content = readFileSync(fullPath, 'utf-8');
          sourceFileCache.set(fullPath, content);
        } catch {
          sourceFileCache.set(fullPath, '');
        }
      }
      return sourceFileCache.get(fullPath) || '';
    };


    const getVisibilitySymbol = (node: CodeNode, rootDir?: string): '+' | '-' |
    undefined => {
      if (node.visibility === 'public') return '+';
      if (node.visibility === 'private' || node.visibility === 'protected') return '-';
      if (node.type === 'file') return undefined;

      // Fallback to source-based inference if repograph doesn't provide visibility.
      const source = getSourceContent(node.filePath, rootDir);
      if (!source) return undefined;
      
      const line = (source.split('\n')[node.startLine - 1] || '').trim();

      // For class members, default is public unless explicitly private/protected.
      if (['method', 'property', 'field'].includes(node.type)) {
        return (line.startsWith('private') || line.startsWith('protected')) ? '-' : '+';
      }

      // For other top-level entities, check for an `export` keyword in the source.
      const name = node.name.split('.').pop() || node.name;
      const isExported = [
        // `export const MyVar`, `export class MyClass`, `export default function ...`
        `export\\s+(default\\s+)?(async\\s+)?(class|function|interface|enum|type|const|let|var|namespace)\\s+${name}\\b`,
        // `export { MyVar }`
        `export\\s*\\{[^}]*\\b${name}\\b`,
        // `export default` for anonymous functions/arrow functions
        name === 'default' ? `export\\s+default\\s+` : null,
      ].filter(Boolean).some(p => new RegExp(p!).test(source));

      if (isExported) {
        return '+';
      }

      return undefined;
    };


    const isComponentNode = (node: CodeNode): boolean =>
      (node.type === 'function' || node.type === 'arrow_function') && /^[A-Z]/.test(node.name);

    const getNodeSymbol = (node: CodeNode): ScnSymbol => {
      // Heuristic: Treat PascalCase functions as components (e.g., React)
      if (isComponentNode(node)) {
        return '◇';
      }
      // Heuristic: Treat uppercase constants/variables as containers (module pattern)
      if ((node.type === 'variable' || node.type === 'constant') && /^[A-Z]/.test(node.name)) {
        return '◇';
      }
      return ENTITY_TYPE_TO_SYMBOL[node.type] ?? '?';
    };


    const getQualifiers = (node: CodeNode, rootDir?: string): { access?: '+' |
    '-'; others: QualifierSymbol[] } => {
      const access = getVisibilitySymbol(node, rootDir);
      
      const others: QualifierSymbol[] = [];
      
      // Check for async
      const isAsync = node.isAsync || (node.codeSnippet && /\basync\s+/.test(node.codeSnippet));
      if (isAsync) others.push('...');
      
      // Check for throw
      const canThrow = node.canThrow || (node.codeSnippet && /\bthrow\b/.test(node.codeSnippet));
      if (canThrow) others.push('!');
      
      // Check for pure function heuristic
      const isPure = node.isPure || isPureFunction(node, rootDir);
      if (isPure) others.push('o');
      
      return { access, others };
    };


    const isPureFunction = (node: CodeNode, rootDir?: string): boolean => {
      if (!['function', 'method', 'arrow_function'].includes(node.type)) return false;
      if (!node.codeSnippet) return false;
      
      // Get the full source to analyze the function body
      const source = getSourceContent(node.filePath, rootDir);
      if (!source) return false;
      
      const lines = source.split('\n');
      const startLine = node.startLine - 1;
      const endLine = node.endLine - 1;
      
      if (startLine < 0 || endLine >= lines.length) return false;
      
      const functionBody = lines.slice(startLine, endLine + 1).join('\n');
      
      // Simple heuristics for pure functions
      const impurePatterns = [
        /console\./,
        /document\./,
        /window\./,
        /localStorage/,
        /sessionStorage/,
        /fetch\(/,
        /XMLHttpRequest/,
        /setTimeout/,
        /setInterval/,
        /Math\.random/,
        /Date\(/,
        /new Date/,
        /\.push\(/,
        /\.pop\(/,
        /\.shift\(/,
        /\.unshift\(/,
        /\.splice\(/,
        /\.sort\(/,
        /\.reverse\(/,
        /\+\+/,
        /--/,
        /\w+\s*=\s*(?!.*return)/,
      ];
      
      // If it contains any impure patterns, it's not pure
      if (impurePatterns.some(pattern => pattern.test(functionBody))) {
        return false;
      }
      
      // If it only contains return statements and basic operations, likely pure
      const hasOnlyReturn = /^\s*export\s+(?:async\s+)?function\s+\w+\([^)]*\)(?:\s*:\s*[^{]+)?\s*{\s*return\s+[^;]+;\s*}\s*$/.test(functionBody.replace(/\n/g, ' '));
      
      return hasOnlyReturn;
    };


    const formatCssIntents = (intents: readonly CssIntent[] = []): string => {
      if (intents.length === 0) return '';
      // Sort intents alphabetically first, then map to symbols
      const sortedIntents = [...intents].sort();
      const symbols = sortedIntents.map(intent => CSS_INTENT_TO_SYMBOL[intent] ?? '');
      return `{ ${symbols.join(' ')} }`;
    };


    const formatFunctionSignature = (snippet: string): string => {
      // Find parameters part, e.g., (a: string, b: number)
      const paramsMatch = snippet.match(/\(([^)]*)\)/);
      let params = '()';
      if (paramsMatch && paramsMatch[1] !== undefined) {
        // Replace type annotations with #
        const paramContent = paramsMatch[1].replace(/:[^\,)]+/g, ': #');
        params = `(${paramContent})`;
      }

      // Find return type, e.g., ): string
      const returnMatch = snippet.match(/\)\s*:\s*([\w\.<>\[\]\| &]+)/);
      let returnType = '';
      if (returnMatch && returnMatch[1]) {
        const type = returnMatch[1].trim();
        if (type !== 'void' && type !== 'any' && type !== 'unknown') {
           returnType = `: #${type}`;
        }
      }

      return `${params}${returnType}`;
    }


    const formatJsxAttributes = (snippet: string): string => {
        const attrs = [];
        const idMatch = snippet.match(/id="([^"]+)"/);
        if (idMatch) attrs.push(`id:#${idMatch[1]}`);
        
        const classMatch = snippet.match(/className="([^"]+)"/);
        if (classMatch?.[1]) {
            const classes = classMatch[1].split(' ').map(c => `.${c}`).join(' ');
            attrs.push(`class:${classes}`);
        }
        
        return attrs.length > 0 ? `[ ${attrs.join(' ')} ]` : '';
    }


    const formatSignature = (node: CodeNode, rootDir?: string): string => {
      if (isComponentNode(node)) {
        // For components, we need to extract props from the full function signature
        // Get the source content to find the complete function definition
        const source = getSourceContent(node.filePath, rootDir);
        if (source) {
          const lines = source.split('\n');
          const startLine = node.startLine - 1;
          const endLine = Math.min(startLine + 10, lines.length); // Look at more lines to get the full signature
          
          // Look for the complete function signature in the source
          const functionText = lines.slice(startLine, endLine).join('\n');
          
          // Try multiple patterns to match React component props
          const patterns = [
            /function\s+\w+\s*\(\s*\{\s*([^}]+)\s*\}\s*:\s*\{[^}]*\}/,  // function Name({ prop1, prop2 }: { ... })
            /\(\s*\{\s*([^}]+)\s*\}\s*:\s*\{[^}]*\}/,                   // ({ prop1, prop2 }: { ... })
            /\(\s*\{\s*([^}]+)\s*\}[^)]*\)/,                            // ({ prop1, prop2 })
          ];
          
          for (const pattern of patterns) {
            const propMatch = functionText.match(pattern);
            if (propMatch?.[1]) {
              const props = propMatch[1].split(',').map(p => p.trim().split(/[:=]/)[0]?.trim()).filter(Boolean);
              const propsString = props.map(p => `${p}:#`).join(', ');
              return `{ props: { ${propsString} } }`;
            }
          }
        }
        return ''; // Component with no destructured props
      }

      // For functions, format as name() instead of showing full code snippet
      if ((node.type === 'function' || node.type === 'method' || node.type === 'constructor' || node.type === 'arrow_function') && node.codeSnippet) {
        return formatFunctionSignature(node.codeSnippet);
      }
      
      // For JSX/HTML elements, show attributes
      if (node.type === 'html_element' && node.codeSnippet) {
        return formatJsxAttributes(node.codeSnippet);
      }

      // For CSS rules, show intents
      if (node.type === 'css_rule' && node.cssIntents) {
        return formatCssIntents(node.cssIntents);
      }

      // For type aliases, show the aliased type
      if (node.type === 'type' && node.codeSnippet) {
         const match = node.codeSnippet.match(/=\s*(.+);?/);
         return match?.[1] ? `= ${match[1].trim().replace(/;$/, '')}` : '';
      }

      // For variables/constants, show the value if it's simple
      if ((node.type === 'variable' || node.type === 'constant') && node.codeSnippet) {
        // For uppercase constants that are treated as modules (◇ symbol), show different formatting
        if (/^[A-Z]/.test(node.name)) {
          // If it's an object literal, show it without = prefix (module pattern)
          if (node.codeSnippet.startsWith('{') && node.codeSnippet.endsWith('}')) {
            return node.codeSnippet;
          }
        }
        
        // For regular variables/constants, add = prefix if needed
        if (!node.codeSnippet.includes('=')) {
          return `= ${node.codeSnippet}`;
        }
        // Extract simple values like "123", "'value'", etc.
        const match = node.codeSnippet.match(/=\s*(.+)$/);
        if (match && match[1]) {
          return `= ${match[1].trim()}`;
        }
        // If no assignment found, just return the snippet
        return node.codeSnippet;
      }
      
      // For container types like class/interface/namespace, we don't show a signature.
      // Their contents are represented by nested symbols.
      if (node.type === 'class' || node.type === 'interface' || node.type === 'namespace') {
        return '';
      }
      
      return '';
    };


    const formatNode = (node: CodeNode, graph: RankedCodeGraph, idManager:
    ScnIdManager, rootDir?: string, level = 0): string => {
      const symbol = getNodeSymbol(node);
      const { access, others } = getQualifiers(node, rootDir);
      const signature = formatSignature(node, rootDir);
      const scnId = idManager.getScnId(node.id);
      const id = scnId ? `(${scnId})` : '';
      const indent = '  '.repeat(level + 1);

      // Build the main line: qualifiers symbol id name signature
      const parts = [];
      if (access) parts.push(access);
      parts.push(symbol);
      if (id) parts.push(id);

      // For functions, combine name and signature without space, unless it's a component
      if (['function', 'method', 'constructor', 'arrow_function'].includes(node.type) && !isComponentNode(node)) {
        const displayName = node.name.includes('.') ? node.name.split('.').pop() || node.name : node.name;
        parts.push(displayName + signature);
      } else {
        const displayName = (node.type === 'property' || node.type === 'field' || node.type === 'html_element') && node.name.includes('.')
          ? node.name.split('.').pop() || node.name
          : node.name;
        parts.push(displayName);
        if (signature) parts.push(signature);
      }

      let mainLine = indent + parts.join(' ');
      if (others.length > 0) {
        // Sort qualifiers in specific order: ... ! o
        const sortedOthers = others.sort((a, b) => {
          const order = ['...', '!', 'o'];
          return order.indexOf(a) - order.indexOf(b);
        });
        mainLine += ` ${sortedOthers.join(' ')}`;
      }

      const formatLinks = (prefix: string, edges: readonly CodeEdge[]): string => {
        if (edges.length === 0) return '';
        const links = edges.map((edge: CodeEdge) => {
          const isCallerLink = prefix === '<-';
          const targetRepographId = isCallerLink ? edge.fromId : edge.toId;
          const targetNode = graph.nodes.get(targetRepographId);
          let targetScnId = idManager.getScnId(targetRepographId);

          // Per spec, file-level dependencies use a .0 suffix.
          // This applies if the target of the link is a file itself.
          if (targetNode?.type === 'file') {
            targetScnId = `${targetScnId}.0`;
          }
          return `(${targetScnId})`;
        }).filter(Boolean).sort().join(', ');

        if (!links) return '';
        return `\n${indent}  ${prefix} ${links}`;
      };

      const dependencyEdges = (graph.edges as CodeEdge[]).filter(edge => edge.fromId === node.id && edge.type !== 'contains');
      const callerEdges = (graph.edges as CodeEdge[]).filter(edge => {
        if (edge.toId !== node.id || edge.type === 'contains') return false;
        
        // For entity nodes, exclude file-level imports entirely
        if (node.type !== 'file' && edge.type === 'imports') return false;
        
        // For entity nodes, also exclude edges from file nodes (file-level dependencies)
        if (node.type !== 'file') {
          const sourceNode = graph.nodes.get(edge.fromId);
          if (sourceNode?.type === 'file') return false;
        }
        
        return edge.type !== 'imports';
      });

      return mainLine + formatLinks('->', dependencyEdges) + formatLinks('<-', callerEdges);
    };


    const serializeFile = (
      fileNode: CodeNode,
      symbols: CodeNode[],
      graph: RankedCodeGraph,
      idManager: ScnIdManager,
      rootDir?: string
    ): string => {
      const scnId = idManager.getScnId(fileNode.id) ?? '';

      const formatFileLinks = (prefix: string, edges: readonly CodeEdge[]): string => {
        if (edges.length === 0) return '';
        const links = edges.map((edge: CodeEdge) => {
          const targetId = prefix === '->' ? edge.toId : edge.fromId;
          const targetNode = graph.nodes.get(targetId);
          
          // If the target is an entity (not a file), we need to get its file's ID
          let fileId: string;
          if (targetNode?.type === 'file') {
            fileId = targetId;
          } else {
            // Find the file that contains this entity
            const entityFilePath = targetNode?.filePath;
            const fileNode = Array.from(graph.nodes.values()).find(n => n.type === 'file' && n.filePath === entityFilePath);
            fileId = fileNode?.id || targetId;
          }
          
          const targetScnId = idManager.getScnId(fileId);
          return `(${targetScnId}.0)`;
        }).filter(Boolean);
        
        // Remove duplicates and sort
        const uniqueLinks = [...new Set(links)].sort().join(', ');
        if (!uniqueLinks) return '';
        return `\n  ${prefix} ${uniqueLinks}`;
      };

      // File-level dependencies: imports or calls from this file to other files
      const fileDependencies = graph.edges.filter(e => 
        e.fromId === fileNode.id && 
        (e.type === 'imports' || (e.type === 'calls' && graph.nodes.get(e.toId)?.type !== 'file'))
      );
      
      // File-level callers: imports or calls to entities in this file from other files  
      const fileCallers = graph.edges.filter(e => {
        const toNode = graph.nodes.get(e.toId);
        const fromNode = graph.nodes.get(e.fromId);
        
        // If the target is an entity in this file and the source is from a different file
        return toNode?.filePath === fileNode.filePath && 
               fromNode?.filePath !== fileNode.filePath &&
               (e.type === 'imports' || e.type === 'calls');
      });

      const formattedPath = fileNode.filePath.includes(' ') ? `"${fileNode.filePath}"` : fileNode.filePath;
      let header = `§ (${scnId}) ${formattedPath}`;
      const fileDepLine = formatFileLinks('->', fileDependencies);
      if (fileDepLine) header += fileDepLine;
      const fileCallerLine = formatFileLinks('<-', fileCallers);
      if (fileCallerLine) header += fileCallerLine;

      // Hierarchical rendering
      const nodeWrappers = symbols.map(s => ({ node: s, children: [] as {node: CodeNode, children: any[]}[] })).sort((a,b) => a.node.startLine - b.node.startLine);
      const topLevelSymbols: typeof nodeWrappers = [];

      for (let i = 0; i < nodeWrappers.length; i++) {
        const currentWrapper = nodeWrappers[i];
        if (!currentWrapper) continue;
        let parentWrapper = null;
        
        // Find the tightest parent by looking backwards through the sorted list
        for (let j = i - 1; j >= 0; j--) {
            const potentialParentWrapper = nodeWrappers[j];
            if (!potentialParentWrapper) continue;
            // Check if current node is contained within the potential parent
            // For JSX elements, use a more flexible containment check
            const isContained = currentWrapper.node.startLine > potentialParentWrapper.node.startLine && 
                               currentWrapper.node.startLine < potentialParentWrapper.node.endLine;
            
            // Additional check for JSX elements - if they're on consecutive lines and the parent is a container element
            const isJsxNesting = currentWrapper.node.type === 'html_element' && 
                                potentialParentWrapper.node.type === 'html_element' &&
                                currentWrapper.node.startLine === potentialParentWrapper.node.startLine + 1;
            
            if (isContained || isJsxNesting) {
                parentWrapper = potentialParentWrapper;
                break;
            }
        }
        
        if (parentWrapper) {
            parentWrapper.children.push(currentWrapper);
        } else {
            topLevelSymbols.push(currentWrapper);
        }
      }

      const nodeLines: string[] = [];
      const processNode = (wrapper: {node: CodeNode, children: any[]}, level: number) => {
        nodeLines.push(formatNode(wrapper.node, graph, idManager, rootDir, level));
        for (const childWrapper of wrapper.children) {
          processNode(childWrapper, level + 1);
        }
      };

      for (const wrapper of topLevelSymbols) {
        processNode(wrapper, 0);
      }

      return [header, ...nodeLines].join('\n');
    };


    /**
     * Serializes a RankedCodeGraph into the SCN text format.
     * This function is the core rendering layer of `scn-ts`.
     *
     * @param graph - The `RankedCodeGraph` produced by `repograph`.
     * @param rootDir - The root directory of the project (for reading source files).
     * @returns A string containing the full SCN map.
     */
    export const serializeGraph = (graph: RankedCodeGraph, rootDir?: string):
    string => {
      const nodesByFile = new Map<string, CodeNode[]>(); // filePath -> nodes
      const fileNodes: CodeNode[] = [];

      for (const node of graph.nodes.values()) {
        if (node.type === 'file') {
          fileNodes.push(node);
          nodesByFile.set(node.filePath, []);
        } else {
          if (!nodesByFile.has(node.filePath)) {
            // This case can happen if repograph finds an entity but not its parent file.
            // We'll create a dummy map entry, but it won't be processed without a file node.
            nodesByFile.set(node.filePath, []); 
          }
          nodesByFile.get(node.filePath)!.push(node);
        }
      }

      const sortedFileNodes = fileNodes.sort((a, b) => a.filePath.localeCompare(b.filePath));
      const idManager = new ScnIdManager(sortedFileNodes, nodesByFile);

      const scnParts = sortedFileNodes.map(fileNode => {
        const symbols = nodesByFile.get(fileNode.filePath) || [];
        // Sort symbols by line number to ensure deterministic output for hierarchical processing
        symbols.sort((a,b) => a.startLine - b.startLine);
        return serializeFile(fileNode, symbols, graph, idManager, rootDir);
      });

      return scnParts.join('\n\n');
    };
approved: true
