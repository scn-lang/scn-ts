uuid: 13328ceb-90f7-4148-8df0-141a021575ca
projectId: scn-ts
createdAt: '2025-07-22T14:50:14.976Z'
linesAdded: 16
linesRemoved: 7
gitCommitMsg: 'fix(types): Resolve strict-mode TypeScript errors'
promptSummary: >-
  Fix a series of TypeScript errors that are preventing the project from
  compiling with `bun tsc`.
reasoning:
  - >-
    I will now address the TypeScript errors you're encountering. Here are the
    patches to fix them, along with my reasoning.
  - '### `repograph/src/pipeline/analyze.ts`'
  - 'I''ll make two changes here:'
  - >-
    1.  Due to the `noUncheckedIndexedAccess` compiler option, accessing any key
    on `languageImportResolvers` (which is a `Record<string, ...>`) results in a
    type of `T | undefined`. I'll add a non-null assertion `!` to
    `languageImportResolvers['default']` to assure TypeScript that the default
    resolver always exists.
  - >-
    2.  For the same reason, `rel.fromId.split('#')[0]` is typed as `string |
    undefined`. The application logic implies `fromId` will always contain at
    least a file path, so `split(...)[0]` will be a string. I'll add a non-null
    assertion `!` to satisfy the type checker.
  - '### `repograph/src/pipeline/analyzer.worker.ts`'
  - 'This file has multiple issues which I''ll fix in a single patch:'
  - >-
    1.  **Error at line 330**: The error `Type 'Node | null | undefined' is not
    assignable to type 'Node | undefined'` is complex. It suggests a mismatch
    where a `null` value is being introduced where it's not expected. The
    expression `selectorsNode.namedChildren[0]` should produce `TSNode |
    undefined`. To resolve this and make the types explicit, I'll add `??
    undefined`. While logically a no-op, it can help the compiler's type
    inference.
  - >-
    2.  **Error at line 352**: `nameNode` can be `undefined` at this point. I'll
    add a guard `&& nameNode` to ensure we only access its properties when it
    exists.
  - >-
    3.  **Error at line 383**: The compiler believes `parser.parse()` can return
    `null`. I'll add a check to handle this possibility and prevent a runtime
    error.
  - >-
    4.  **Error at line 415**: The relation type `'exports'` is not defined in
    `UnresolvedRelation`. This seems to be part of an incomplete feature for
    handling re-exports. Since an `'imports'` relation is already created, which
    is sufficient for file dependency, I will comment out the line that adds the
    `'exports'` relation to resolve the type error.
  - '### `src/cli.ts`'
  - >-
    When parsing command-line arguments, `cliArgs[++i]` can be `undefined` if an
    option that requires a value is the last argument. `parseInt` requires a
    string, so I'll add a check to ensure `value` is not `undefined` before
    using it.
  - '### `test/ts/unit/jsx.test.ts`'
  - >-
    The `noUncheckedIndexedAccess` option is again the cause of errors here.
    Even though `findIndex` is checked to not be `-1`, accessing
    `lines[mainIndex]` is still considered potentially `undefined`. Since the
    test logic ensures the index is valid, I'll add non-null assertions (`!`) to
    tell TypeScript the access is safe.
  - These changes should resolve all the reported TypeScript errors.
operations:
  - type: write
    path: repograph/src/pipeline/analyze.ts
    content: >-
      --- repograph/src/pipeline/analyze.ts

      +++ repograph/src/pipeline/analyze.ts

      @@ -94,7 +94,7 @@
         },
       };
       
      -const getImportResolver = (langName: string): ImportResolver =>
      languageImportResolvers[langName] ?? languageImportResolvers['default'];

      +const getImportResolver = (langName: string): ImportResolver =>
      languageImportResolvers[langName] ?? languageImportResolvers['default']!;
       
       class SymbolResolver {
         private fileImports = new Map<string, string[]>();
      @@ -210,7 +210,7 @@
           for (const rel of unresolvedRelations) {
               if (rel.type === 'imports') continue; // Already handled
               
      -        const toNode = symbolResolver.resolve(rel.toName,
      rel.fromId.split('#')[0]);

      +        const toNode = symbolResolver.resolve(rel.toName,
      rel.fromId.split('#')[0]!);
               if (toNode && rel.fromId !== toNode.id) {
                 const edgeType = rel.type === 'reference' ? 'calls' : rel.type;
                 edges.push({ fromId: rel.fromId, toId: toNode.id, type: edgeType });
    patchStrategy: new-unified
  - type: write
    path: repograph/src/pipeline/analyzer.worker.ts
    content: >-
      --- repograph/src/pipeline/analyzer.worker.ts

      +++ repograph/src/pipeline/analyzer.worker.ts

      @@ -327,7 +327,7 @@
       
         if (symbolType === 'css_rule' && !nameNode) {
           const selectorsNode = node.childForFieldName('selectors') || node.namedChildren.find(c => c && c.type === 'selectors');
      -    if (selectorsNode) nameNode = selectorsNode.namedChildren[0];

      +    if (selectorsNode) nameNode = selectorsNode.namedChildren[0] ??
      undefined;
         }
       
         let symbolName: string;
      @@ -348,7 +348,7 @@
         }
       
         let symbolId = `${file.path}#${symbolName}`;
      -  if (symbolType === 'html_element') symbolId =
      `${file.path}#${symbolName}:${nameNode.startPosition.row + 1}`;

      +  if (symbolType === 'html_element' && nameNode) symbolId =
      `${file.path}#${symbolName}:${nameNode.startPosition.row + 1}`;
       
         if (symbolName && !processedSymbols.has(symbolId) && !nodes.some(n => n.id === symbolId)) {
           processedSymbols.add(symbolId);
      @@ -374,7 +374,8 @@
         if (!parser.language) return { nodes, relations };
         
         const query = new (await import('web-tree-sitter')).Query(parser.language, langConfig.query);
         const tree = parser.parse(file.content);
      +  if (!tree) return { nodes, relations };
         const captures = query.captures(tree.rootNode);
       
         // --- Phase 1: Definitions ---
      @@ -399,8 +400,12 @@
             // Handle re-exports, e.g., `export * from './other';`
             const exportParent = node.parent?.parent;
             if (exportParent?.type === 'export_statement') {
      -        // This creates a file-level dependency, which is what SCN
      represents.

      -        relations.push({ fromId: file.path, toName: importPath, type:
      'exports' });

      +        // This creates a file-level dependency, which is what SCN
      represents.

      +        // NOTE: The 'exports' relation type is not defined, causing a TS
      error.

      +        // A simple 'imports' relation is already created above, which is
      sufficient

      +        // for file-level dependency tracking. Deeper re-export symbol
      resolution

      +        // is not yet implemented.

      +        // relations.push({ fromId: file.path, toName: importPath, type:
      'exports' });
             }
             continue;
           }
    patchStrategy: new-unified
  - type: write
    path: src/cli.ts
    content: |-
      --- src/cli.ts
      +++ src/cli.ts
      @@ -46,15 +46,20 @@
           const config = ARG_CONFIG[arg];
           if (config) {
             if (config.takesValue) {
               const value = cliArgs[++i];
      +        if (value === undefined) {
      +          console.error(`Error: Missing value for argument ${arg}`);
      +          process.exit(1);
      +        }
               if (config.key === 'maxWorkers') {
                 const numValue = parseInt(value, 10);
                 if (isNaN(numValue) || numValue < 1) {
                   console.error(`Invalid value for --max-workers: ${value}. Must be a positive integer.`);
                   process.exit(1);
                 }
                 (options as any)[config.key] = numValue;
               } else {
                 (options as any)[config.key] = value;
    patchStrategy: new-unified
  - type: write
    path: test/ts/unit/jsx.test.ts
    content: >-
      --- test/ts/unit/jsx.test.ts

      +++ test/ts/unit/jsx.test.ts

      @@ -60,8 +60,8 @@
           expect(h1Index).toBeGreaterThan(-1);
           expect(h1Index).toBe(mainIndex + 1);
           
      -    const mainIndentation = lines[mainIndex].match(/^\s*/)?.[0].length ??
      0;

      -    const h1Indentation = lines[h1Index].match(/^\s*/)?.[0].length ?? 0;

      +    const mainIndentation = lines[mainIndex]!.match(/^\s*/)?.[0].length
      ?? 0;

      +    const h1Indentation = lines[h1Index]!.match(/^\s*/)?.[0].length ?? 0;
           
           expect(h1Indentation).toBeGreaterThan(mainIndentation);
         });
    patchStrategy: new-unified
snapshot:
  repograph/src/pipeline/analyze.ts: >-
    import path from 'node:path';

    import type { Analyzer, CodeNode, CodeEdge, FileContent, UnresolvedRelation
    } from '../types.js';

    import { getLanguageConfigForFile, type LanguageConfig } from
    '../tree-sitter/language-config.js';

    import { logger } from '../utils/logger.util.js';

    import { ParserError } from '../utils/error.util.js';

    import { fileURLToPath } from 'node:url';

    import Tinypool from 'tinypool';

    import processFileInWorker from './analyzer.worker.js';


    const normalizePath = (p: string) => p.replace(/\\/g, '/');


    // --- LANGUAGE-SPECIFIC IMPORT RESOLUTION LOGIC ---

    // This part is needed on the main thread to resolve import paths.


    const createModuleResolver = (extensions: string[]) => (fromFile: string,
    sourcePath: string, allFiles: string[]): string | null => {
      const basedir = normalizePath(path.dirname(fromFile));
      const importPath = normalizePath(path.join(basedir, sourcePath));

      // First, check if the path as-is (with extension) exists
      if (path.extname(importPath) && allFiles.includes(importPath)) {
        return importPath;
      }

      const parsedPath = path.parse(importPath);
      const basePath = normalizePath(path.join(parsedPath.dir, parsedPath.name));
      for (const ext of extensions) {
          const potentialFile = basePath + ext;
          if (allFiles.includes(potentialFile)) return potentialFile;
      }
      
      for (const ext of extensions) {
          const potentialIndexFile = normalizePath(path.join(importPath, 'index' + ext));
          if (allFiles.includes(potentialIndexFile)) return potentialIndexFile;
      }

      if (allFiles.includes(importPath)) return importPath;
      return null;      
    };


    const resolveImportFactory = (endings: string[], packageStyle: boolean =
    false) => (fromFile: string, sourcePath: string, allFiles: string[]): string
    | null => {
      const basedir = normalizePath(path.dirname(fromFile));
      const resolvedPathAsIs = normalizePath(path.join(basedir, sourcePath));
      if (allFiles.includes(resolvedPathAsIs)) return resolvedPathAsIs;

      const parsedSourcePath = path.parse(sourcePath);
      const basePath = normalizePath(path.join(basedir, parsedSourcePath.dir, parsedSourcePath.name));
      for (const end of endings) {
        const potentialPath = basePath + end;
        if (allFiles.includes(potentialPath)) return potentialPath;
      }
      
      if (packageStyle && sourcePath.includes('.')) {
        const packagePath = normalizePath(sourcePath.replace(/\./g, '/'));
        for (const end of endings) {
          const fileFromRoot = packagePath + end;
          if (allFiles.includes(fileFromRoot)) return fileFromRoot;
        }
      }
      return null;
    };


    type ImportResolver = (fromFile: string, sourcePath: string, allFiles:
    string[]) => string | null;


    const languageImportResolvers: Record<string, ImportResolver> = {
      default: (fromFile, sourcePath, allFiles) => {
        const resolvedPathAsIs = path.normalize(path.join(path.dirname(fromFile), sourcePath));
        return allFiles.includes(resolvedPathAsIs) ? resolvedPathAsIs : null;
      },
      typescript: createModuleResolver(['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs', '.css']),
      javascript: createModuleResolver(['.js', 'jsx', '.mjs', '.cjs']),
      tsx: createModuleResolver(['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs', '.css']),
      python: (fromFile: string, sourcePath: string, allFiles: string[]): string | null => {
        const basedir = normalizePath(path.dirname(fromFile));
        if (sourcePath.startsWith('.')) {
          const level = sourcePath.match(/^\.+/)?.[0]?.length ?? 0;
          const modulePath = sourcePath.substring(level).replace(/\./g, '/');
          let currentDir = basedir;
          for (let i = 1; i < level; i++) currentDir = path.dirname(currentDir);
          const targetPyFile = normalizePath(path.join(currentDir, modulePath) + '.py');
          if (allFiles.includes(targetPyFile)) return targetPyFile;
          const resolvedPath = normalizePath(path.join(currentDir, modulePath, '__init__.py'));
          if (allFiles.includes(resolvedPath)) return resolvedPath;
        }
        return resolveImportFactory(['.py', '/__init__.py'])(fromFile, sourcePath, allFiles);
      },
      java: resolveImportFactory(['.java'], true),
      csharp: resolveImportFactory(['.cs'], true),
      php: resolveImportFactory(['.php']),
      rust: (fromFile: string, sourcePath: string, allFiles: string[]): string | null => {
        const basedir = normalizePath(path.dirname(fromFile));
        const resolvedPath = normalizePath(path.join(basedir, sourcePath + '.rs'));
        if (allFiles.includes(resolvedPath)) return resolvedPath;
        return resolveImportFactory(['.rs', '/mod.rs'])(fromFile, sourcePath, allFiles);
      },
    };


    const getImportResolver = (langName: string): ImportResolver =>
    languageImportResolvers[langName] ?? languageImportResolvers['default'];


    class SymbolResolver {
      private fileImports = new Map<string, string[]>();

      constructor(private nodes: ReadonlyMap<string, CodeNode>, edges: readonly CodeEdge[]) {
        for (const edge of edges) {
          if (edge.type === 'imports') {
            if (!this.fileImports.has(edge.fromId)) this.fileImports.set(edge.fromId, []);
            this.fileImports.get(edge.fromId)!.push(edge.toId);
          }
        }
      }

      resolve(symbolName: string, contextFile: string): CodeNode | null {
        // 1. Same file
        const sameFileId = `${contextFile}#${symbolName}`;
        if (this.nodes.has(sameFileId)) return this.nodes.get(sameFileId)!;

        // 2. Imported files
        const importedFiles = this.fileImports.get(contextFile) || [];
        for (const file of importedFiles) {
          const importedId = `${file}#${symbolName}`;
          if (this.nodes.has(importedId)) return this.nodes.get(importedId)!;
        }
        
        // 3. CSS Selector
        for (const node of this.nodes.values()) {
            if (node.type === 'css_rule' && node.cssSelector === symbolName) return node;
        }

        // 4. Global fallback
        for (const node of this.nodes.values()) {
          if (node.name === symbolName && ['class', 'function', 'interface', 'struct', 'type', 'enum'].includes(node.type)) {
            return node;
          }
        }

        return null;
      }
    }


    export const createTreeSitterAnalyzer = (options: { maxWorkers?: number } =
    {}): Analyzer => {
      const { maxWorkers = 1 } = options;
      
      return async (files: readonly FileContent[]) => {
        const nodes = new Map<string, CodeNode>();
        let unresolvedRelations: UnresolvedRelation[] = [];
        const allFilePaths = files.map(f => normalizePath(f.path));

        for (const file of files) {
          const langConfig = getLanguageConfigForFile(normalizePath(file.path));
          nodes.set(file.path, {
            id: file.path, type: 'file', name: path.basename(file.path),
            filePath: file.path, startLine: 1, endLine: file.content.split('\n').length,
            language: langConfig?.name,
          });
        }

        const filesToProcess = files.map(file => ({ file, langConfig: getLanguageConfigForFile(normalizePath(file.path)) }))
          .filter((item): item is { file: FileContent, langConfig: LanguageConfig } => !!item.langConfig);
        
        if (maxWorkers > 1) {
          logger.debug(`Analyzing files in parallel with ${maxWorkers} workers.`);
          const pool = new Tinypool({
            filename: fileURLToPath(new URL('analyzer.worker.js', import.meta.url)),
            maxThreads: maxWorkers,
          });

          const tasks = filesToProcess.map(item => pool.run(item));
          const results = await Promise.all(tasks);
          
          for (const result of results) {
            if (result) {
              result.nodes.forEach((node: CodeNode) => nodes.set(node.id, node));
              unresolvedRelations.push(...result.relations);
            }
          }
        } else {
          logger.debug(`Analyzing files sequentially in the main thread.`);
          for (const item of filesToProcess) {
            try {
              const result = await processFileInWorker(item);
              if (result) {
                result.nodes.forEach(node => nodes.set(node.id, node));
                unresolvedRelations.push(...result.relations);
              }
            } catch(error) {
              logger.warn(new ParserError(`Failed to process ${item.file.path}`, item.langConfig.name, error));
            }
          }
        }

        // --- Phase 3: Resolve all relationships ---
        const edges: CodeEdge[] = [];
        const importEdges: CodeEdge[] = [];
        
        // Resolve imports first, as they are needed by the SymbolResolver
        for (const rel of unresolvedRelations) {
          if (rel.type === 'imports') {
            const fromNode = nodes.get(rel.fromId);
            if (!fromNode || fromNode.type !== 'file' || !fromNode.language) continue;
            
            const resolver = getImportResolver(fromNode.language);
            const toId = resolver(rel.fromId, rel.toName, allFilePaths);
            if (toId && nodes.has(toId)) {
              importEdges.push({ fromId: rel.fromId, toId, type: 'imports' });
            }
          }
        }
        
        const symbolResolver = new SymbolResolver(nodes, importEdges);

        for (const rel of unresolvedRelations) {
            if (rel.type === 'imports') continue; // Already handled
            
            const toNode = symbolResolver.resolve(rel.toName, rel.fromId.split('#')[0]);
            if (toNode && rel.fromId !== toNode.id) {
              const edgeType = rel.type === 'reference' ? 'calls' : rel.type;
              edges.push({ fromId: rel.fromId, toId: toNode.id, type: edgeType });
            }
        }
        
        const finalEdges = [...importEdges, ...edges];
        // Remove duplicates
        const uniqueEdges = [...new Map(finalEdges.map(e => [`${e.fromId}->${e.toId}->${e.type}`, e])).values()];

        return { nodes: Object.freeze(nodes), edges: Object.freeze(uniqueEdges) };
      };
    };
  repograph/src/pipeline/analyzer.worker.ts: >-
    import type { Node as TSNode, QueryCapture as TSMatch } from
    'web-tree-sitter';

    import { createParserForLanguage } from '../tree-sitter/languages.js';

    import type { LanguageConfig } from '../tree-sitter/language-config.js';

    import type { Analyzer, CodeNode, CodeNodeType, CodeNodeVisibility,
    FileContent, UnresolvedRelation } from '../types.js';


    // --- UTILITY FUNCTIONS (mirrored from original analyze.ts) ---


    const getNodeText = (node: TSNode, content: string): string =>
    content.slice(node.startIndex, node.endIndex);

    const getLineFromIndex = (content: string, index: number): number =>
    content.substring(0, index).split('\n').length;


    const extractCodeSnippet = (symbolType: CodeNodeType, node: TSNode): string
    => {
      const text = node.text;
      switch (symbolType) {
        case 'variable': case 'constant': case 'property': {
          const assignmentMatch = text.match(/=\s*(.+)$/s);
          return (assignmentMatch?.[1] ?? text).trim();
        }
        case 'field': {
          const colonIndex = text.indexOf(':');
          if (colonIndex !== -1) return text.substring(colonIndex).trim();
          const equalsIndex = text.indexOf('=');
          if (equalsIndex !== -1) return text.substring(equalsIndex).trim();
          return text.trim();
        }
        case 'function': case 'method': case 'constructor': {
          const bodyStart = text.indexOf('{');
          return (bodyStart > -1 ? text.slice(0, bodyStart) : text).trim();
        }
        case 'arrow_function': {
          const arrowIndex = text.indexOf('=>');
          return arrowIndex > -1 ? text.slice(0, arrowIndex).trim() : text.trim();
        } 
        default: return text.trim();
      }
    };


    const extractQualifiers = (childCaptures: TSMatch[], fileContent: string,
    handler: Partial<LanguageHandler>) => {
      const qualifiers: { [key: string]: TSNode } = {};
      for (const capture of childCaptures) qualifiers[capture.name] = capture.node;
      
      const visibility = (qualifiers['qualifier.visibility'] ? getNodeText(qualifiers['qualifier.visibility'], fileContent) : undefined) as CodeNodeVisibility | undefined;
      const returnType = qualifiers['symbol.returnType'] ? getNodeText(qualifiers['symbol.returnType'], fileContent).replace(/^:\s*/, '') : undefined;
      const parameters = qualifiers['symbol.parameters'] && handler.parseParameters ? handler.parseParameters(qualifiers['symbol.parameters'], fileContent) : undefined;
      const canThrow = childCaptures.some(c => c.name === 'qualifier.throws');
      
      return { qualifiers, visibility, returnType, parameters, canThrow, isAsync: !!qualifiers['qualifier.async'], isStatic: !!qualifiers['qualifier.static'] };
    };


    const getCssIntents = (ruleNode: TSNode, content: string): readonly
    ('layout' | 'typography' | 'appearance')[] => {
      const intents = new Set<'layout' | 'typography' | 'appearance'>();
      const layoutProps = /^(display|position|flex|grid|width|height|margin|padding|transform|align-|justify-)/;
      const typographyProps = /^(font|text-|line-height|letter-spacing|word-spacing)/;
      const appearanceProps = /^(background|border|box-shadow|opacity|color|fill|stroke|cursor)/;
      const block = ruleNode.childForFieldName('body') ?? ruleNode.namedChildren.find(c => c && c.type === 'block');
      
      if (block) {
        for (const declaration of block.namedChildren) {
          if (declaration && declaration.type === 'declaration') {
            const propNode = declaration.namedChildren.find(c => c && c.type === 'property_name');
            if (propNode) {
              const propName = getNodeText(propNode, content);
              if (layoutProps.test(propName)) intents.add('layout');
              if (typographyProps.test(propName)) intents.add('typography');
              if (appearanceProps.test(propName)) intents.add('appearance');
            }
          }
        }
      }
      return Array.from(intents).sort();
    };


    // --- LANGUAGE-SPECIFIC LOGIC ---


    type LanguageHandler = {
      preProcessFile?: (file: FileContent, captures: TSMatch[]) => Record<string, any>;
      shouldSkipSymbol: (node: TSNode, symbolType: CodeNodeType, langName: string) => boolean;
      getSymbolNameNode: (declarationNode: TSNode, originalNode: TSNode) => TSNode | null;
      processComplexSymbol?: (context: ProcessSymbolContext) => boolean;
      parseParameters?: (paramsNode: TSNode, content: string) => { name: string; type?: string }[];
    };


    type ProcessSymbolContext = {
      nodes: CodeNode[];
      file: FileContent;
      node: TSNode;
      symbolType: CodeNodeType;
      processedSymbols: Set<string>;
      fileState: Record<string, any>;
      childCaptures: TSMatch[];
    };


    const pythonHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'expression_statement') {
          const assignmentNode = declarationNode.namedChild(0);
          if (assignmentNode?.type === 'assignment') return assignmentNode.childForFieldName('left');
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const goLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        const nodeType = declarationNode.type;
        if (['type_declaration', 'const_declaration', 'var_declaration'].includes(nodeType)) {
          const spec = declarationNode.namedChild(0);
          if (spec && ['type_spec', 'const_spec', 'var_spec'].includes(spec.type)) return spec.childForFieldName('name');
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const cLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'type_definition') {
          const lastChild = declarationNode.namedChild(declarationNode.namedChildCount - 1);
          if (lastChild?.type === 'type_identifier') return lastChild;
        }
        if (declarationNode.type === 'function_definition') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') {
            const nameNode = declarator.childForFieldName('declarator');
            if (nameNode?.type === 'identifier') return nameNode;
          }
        }
        if (declarationNode.type === 'field_declaration') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') return declarator.childForFieldName('declarator');
          return declarator;
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const tsLangHandler: Partial<LanguageHandler> = {
      preProcessFile: (_file, captures) => {
        const classNames = new Map<string, number>(); const duplicateClassNames = new Set<string>(); const seenClassNodes = new Set<number>();
        for (const { name, node } of captures) {
          if (name === 'class.definition') {
            let classNode = node.type === 'export_statement' ? (node.namedChildren[0] ?? node) : node;
            if (classNode.type === 'class_declaration' && !seenClassNodes.has(classNode.startIndex)) {
              seenClassNodes.add(classNode.startIndex);
              const nameNode = classNode.childForFieldName('name');
              if (nameNode) {
                const className = nameNode.text; const count = classNames.get(className) || 0;
                classNames.set(className, count + 1);
                if (count + 1 > 1) duplicateClassNames.add(className);
              }
            }
          }
        }
        return { duplicateClassNames };
      },
      shouldSkipSymbol: (node, symbolType, langName) => {
        if (langName !== 'typescript') return false;
        const valueNode = node.childForFieldName('value');
        if (valueNode?.type !== 'arrow_function') return false;
        return (symbolType === 'field' && node.type === 'public_field_definition') || (symbolType === 'variable' && node.type === 'variable_declarator');
      },
      getSymbolNameNode: (declarationNode, originalNode) => {
        if (originalNode.type === 'variable_declarator' || originalNode.type === 'public_field_definition') return originalNode.childForFieldName('name');
        if (declarationNode.type === 'export_statement') {
          const { firstNamedChild } = declarationNode;
          if (firstNamedChild?.type === 'arrow_function') {
            // For export default arrow functions, create a synthetic 'default' name
            return null; // Will be handled by fallback logic below
          }
          // Handle `export default function() {}`
          if (firstNamedChild?.type === 'function_declaration' && !firstNamedChild.childForFieldName('name')) {
            return null; // Will be handled by fallback logic below
          }
          const lexicalDecl = declarationNode.namedChildren[0];
          if (lexicalDecl?.type === 'lexical_declaration') {
            const varDeclarator = lexicalDecl.namedChildren[0];
            if (varDeclarator?.type === 'variable_declarator') return varDeclarator.childForFieldName('name');
          }
        }
        return declarationNode.childForFieldName('name');
      },
      processComplexSymbol: ({ nodes, file, node, symbolType, processedSymbols, fileState, childCaptures }) => {
        if (symbolType !== 'method' && symbolType !== 'field') return false;
        const classParent = node.parent?.parent;
        if (classParent?.type === 'class_declaration') {
          const classNameNode = classParent.childForFieldName('name');
          if (classNameNode) {
            const className = classNameNode.text;
            const nameNode = node.childForFieldName('name');
            if (nameNode && !fileState['duplicateClassNames']?.has(className)) {
              const methodName = nameNode.text;
              const unqualifiedSymbolId = `${file.path}#${methodName}`;
              if (!processedSymbols.has(unqualifiedSymbolId) && !nodes.some(n => n.id === unqualifiedSymbolId)) {
                processedSymbols.add(unqualifiedSymbolId);
                const codeSnippet = extractCodeSnippet(symbolType, node);
                const q = extractQualifiers(childCaptures, file.content, tsLangHandler);
                nodes.push({
                  id: unqualifiedSymbolId, type: symbolType, name: methodName, filePath: file.path,
                  startLine: getLineFromIndex(file.content, node.startIndex), endLine: getLineFromIndex(file.content, node.endIndex),
                  codeSnippet, ...(q.isAsync && { isAsync: true }), ...(q.isStatic && { isStatic: true }),
                  ...(q.visibility && { visibility: q.visibility }), ...(q.returnType && { returnType: q.returnType }),
                  ...(q.parameters && { parameters: q.parameters }), ...(q.canThrow && { canThrow: true }),
                });
              }
              processedSymbols.add(`${file.path}#${methodName}`);
            }
          }
        }
        return true;
      },
      parseParameters: (paramsNode: TSNode, content: string): { name: string; type?: string }[] => {
        const params: { name: string; type?: string }[] = [];
        // Handle object destructuring in props: `({ prop1, prop2 })`
        if (paramsNode.type === 'object_pattern') {
          for (const child of paramsNode.namedChildren) {
            if (child && (child.type === 'shorthand_property_identifier' || child.type === 'property_identifier')) {
              params.push({ name: getNodeText(child, content), type: '#' });
            }
          }
          return params;
        }

        for (const child of paramsNode.namedChildren) {
          if (child && (child.type === 'required_parameter' || child.type === 'optional_parameter')) {
            const nameNode = child.childForFieldName('pattern');
            const typeNode = child.childForFieldName('type');
            if (nameNode) params.push({ name: getNodeText(nameNode, content), type: typeNode ? getNodeText(typeNode, content).replace(/^:\s*/, '') : undefined });
          }
        }
        return params;
      },
    };


    const phpHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'namespace_definition') return declarationNode.childForFieldName('name');
        return declarationNode.childForFieldName('name');
      },
    };


    const languageHandlers: Record<string, Partial<LanguageHandler>> = {
      default: { shouldSkipSymbol: () => false, getSymbolNameNode: (declarationNode) => declarationNode.childForFieldName('name') },
      typescript: tsLangHandler, tsx: tsLangHandler,
      python: pythonHandler, go: goLangHandler, rust: goLangHandler,
      c: cLangHandler, cpp: cLangHandler, php: phpHandler,
    };


    const getLangHandler = (langName: string): LanguageHandler => ({
    ...languageHandlers['default'], ...languageHandlers[langName] } as
    LanguageHandler);


    function getSymbolTypeFromCapture(captureName: string, type: string):
    CodeNodeType | null {
      const baseMap = new Map<string, CodeNodeType>([
        ['class', 'class'], ['function', 'function'], ['function.arrow', 'arrow_function'], ['interface', 'interface'],
        ['type', 'type'], ['method', 'method'], ['field', 'field'], ['struct', 'struct'], ['enum', 'enum'],
        ['namespace', 'namespace'], ['trait', 'trait'], ['impl', 'impl'], ['constructor', 'constructor'], ['property', 'property'],
        ['html.element', 'html_element'], ['css.rule', 'css_rule'], ['variable', 'variable'], ['constant', 'constant'],
        ['static', 'static'], ['union', 'union'], ['template', 'template'],
      ]);
      return baseMap.get(captureName) ?? baseMap.get(type) ?? null;
    }


    function findEnclosingSymbolId(startNode: TSNode, file: FileContent, nodes:
    readonly CodeNode[]): string | null {
      let current: TSNode | null = startNode.parent;
      while (current) {
        const nodeType = current.type;
        // Prioritize function-like parents for accurate call linking
        if (['function_declaration', 'method_definition', 'arrow_function', 'function_definition'].includes(nodeType)) {
          const nameNode = current.childForFieldName('name');
          if (nameNode) {
            let symbolName = nameNode.text;
            // Handle class methods
            if (nodeType === 'method_definition') {
              const classNode = current.parent?.parent;
              if (classNode?.type === 'class_declaration') {
                const className = classNode.childForFieldName('name')?.text;
                if (className) symbolName = `${className}.${symbolName}`;
              }
            }
            const symbolId = `${file.path}#${symbolName}`;
            if (nodes.some(n => n.id === symbolId)) return symbolId;
          }
        }
        // Fallback for other symbol types
        if (current.type === 'jsx_opening_element') {
          const tagNameNode = current.childForFieldName('name');
          if (tagNameNode) {
            const tagName = tagNameNode.text, lineNumber = tagNameNode.startPosition.row + 1;
            const symbolId = `${file.path}#${tagName}:${lineNumber}`;
            if (nodes.some(n => n.id === symbolId)) return symbolId;
          }
        }
        const nameNode = current.childForFieldName('name');
        if (nameNode) {
          let symbolName = nameNode.text;
          if (current.type === 'method_definition' || (current.type === 'public_field_definition' && !current.text.includes('=>'))) {
            const classNode = current.parent?.parent;
            if (classNode?.type === 'class_declaration') symbolName = `${classNode.childForFieldName('name')?.text}.${symbolName}`;
          }
          const symbolId = `${file.path}#${symbolName}`;
          if (nodes.some(n => n.id === symbolId)) return symbolId;
        }
        current = current.parent;
      }
      return file.path;
    }


    function processSymbol(context: ProcessSymbolContext, langConfig:
    LanguageConfig): void {
      const { nodes, file, node, symbolType, processedSymbols, childCaptures } = context;
      const handler = getLangHandler(langConfig.name);

      if (handler.shouldSkipSymbol(node, symbolType, langConfig.name)) return;
      if (handler.processComplexSymbol?.(context)) return;

      // Skip local variable declarations inside functions
      if (symbolType === 'variable') {
        let current = node.parent;
        while (current) {
          if (['function_declaration', 'arrow_function', 'method_definition'].includes(current.type)) {
            return; // Skip this variable as it's inside a function
          }
          current = current.parent;
        }
      }

      let declarationNode = node;
      if (node.type === 'export_statement' && node.namedChildCount > 0) declarationNode = node.namedChildren[0] ?? node;
      
      const q = extractQualifiers(childCaptures, file.content, handler);
      let nameNode = handler.getSymbolNameNode(declarationNode, node) || q.qualifiers['html.tag'] || q.qualifiers['css.selector'];

      if (symbolType === 'css_rule' && !nameNode) {
        const selectorsNode = node.childForFieldName('selectors') || node.namedChildren.find(c => c && c.type === 'selectors');
        if (selectorsNode) nameNode = selectorsNode.namedChildren[0];
      }

      let symbolName: string;
      if (!nameNode) {
        // Handle export default anonymous functions
        if (node.type === 'export_statement') {
          const firstChild = node.firstNamedChild;
          if (firstChild?.type === 'arrow_function' || 
              (firstChild?.type === 'function_declaration' && !firstChild.childForFieldName('name'))) {
            symbolName = 'default';
          } else {
            return;
          }
        } else {
          return;
        }
      } else {
        symbolName = nameNode.text;
      }

      let symbolId = `${file.path}#${symbolName}`;
      if (symbolType === 'html_element') symbolId = `${file.path}#${symbolName}:${nameNode.startPosition.row + 1}`;

      if (symbolName && !processedSymbols.has(symbolId) && !nodes.some(n => n.id === symbolId)) {
        processedSymbols.add(symbolId);
        const isHtmlElement = symbolType === 'html_element', isCssRule = symbolType === 'css_rule';
        const cssIntents = isCssRule ? getCssIntents(node, file.content) : undefined;
        const codeSnippet = extractCodeSnippet(symbolType, node);
        nodes.push({
          id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
          startLine: getLineFromIndex(file.content, node.startIndex), endLine: getLineFromIndex(file.content, node.endIndex),
          codeSnippet, ...(q.isAsync && { isAsync: true }), ...(q.isStatic && { isStatic: true }),
          ...(q.visibility && { visibility: q.visibility }), ...(q.returnType && { returnType: q.returnType }),
          ...(q.parameters && { parameters: q.parameters }), ...(q.canThrow && { canThrow: true }),
          ...(isHtmlElement && { htmlTag: symbolName }), ...(isCssRule && { cssSelector: symbolName }),
          ...(cssIntents && { cssIntents }),
        });
      }
    }


    // --- MAIN WORKER FUNCTION ---


    export default async function processFile({ file, langConfig }: { file:
    FileContent; langConfig: LanguageConfig; }) {
      const nodes: CodeNode[] = [];
      const relations: UnresolvedRelation[] = [];
      const processedSymbols = new Set<string>();

      const parser = await createParserForLanguage(langConfig);
      if (!parser.language) return { nodes, relations };
      
      const query = new (await import('web-tree-sitter')).Query(parser.language, langConfig.query);
      const tree = parser.parse(file.content);
      const captures = query.captures(tree.rootNode);

      // --- Phase 1: Definitions ---
      const handler = getLangHandler(langConfig.name);
      const fileState = handler.preProcessFile?.(file, captures) || {};
      const definitionCaptures = captures.filter(({ name }) => name.endsWith('.definition'));
      const otherCaptures = captures.filter(({ name }) => !name.endsWith('.definition'));

      for (const { name, node } of definitionCaptures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const symbolType = getSymbolTypeFromCapture(name, type);
        if (!symbolType) continue;

        const childCaptures = otherCaptures.filter((c) => c.node.startIndex >= node.startIndex && c.node.endIndex <= node.endIndex);
        processSymbol({ nodes, file, node, symbolType, processedSymbols, fileState, childCaptures }, langConfig);
      }

      // --- Phase 2: Relationships ---
      for (const { name, node } of captures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const subtype = parts[parts.length - 1];

        if (type === 'import' && subtype === 'source') {
          const importPath = getNodeText(node, file.content).replace(/['"`]/g, '');
          relations.push({ fromId: file.path, toName: importPath, type: 'imports' });

          // Handle re-exports, e.g., `export * from './other';`
          const exportParent = node.parent?.parent;
          if (exportParent?.type === 'export_statement') {
            // This creates a file-level dependency, which is what SCN represents.
            relations.push({ fromId: file.path, toName: importPath, type: 'exports' });
          }
          continue;
        }

        if (name === 'css.class.reference' || name === 'css.id.reference') {
          const fromId = findEnclosingSymbolId(node, file, nodes);
          if (!fromId) continue;

          const fromNode = nodes.find(n => n.id === fromId);
          if (fromNode?.type !== 'html_element') continue;

          const text = getNodeText(node, file.content).replace(/['"`]/g, '');
          const prefix = name === 'css.id.reference' ? '#' : '.';
          const selectors = (prefix === '.') ? text.split(' ').filter(Boolean).map(s => '.' + s) : [prefix + text];

          for (const selector of selectors) relations.push({ fromId, toName: selector, type: 'reference' });
          continue;
        }

        if (subtype && ['inheritance', 'implementation', 'call', 'reference'].includes(subtype)) {
          const fromId = findEnclosingSymbolId(node, file, nodes);
          if (!fromId) continue;
          
          const toName = getNodeText(node, file.content).replace(/<.*>$/, '');
          const edgeType = subtype === 'inheritance' ? 'inherits' : subtype === 'implementation' ? 'implements' : 'reference';
          relations.push({ fromId, toName, type: edgeType });
        }
      }

      return { nodes, relations };
    }
  src/cli.ts: >-
    import { generateScn, type ScnTsConfig } from './index.js';

    import { existsSync, readFileSync, watch } from 'fs';

    import { writeFile } from 'fs/promises';

    import { resolve, join, relative } from 'path';

    import { version } from '../package.json';


    interface CliOptions {
      include: string[];
      output?: string;
      project?: string;
      config?: string;
      maxWorkers?: number;
      watch: boolean;
      help: boolean;
      version: boolean;
    }


    const ARG_CONFIG: Record<string, { key: keyof CliOptions; takesValue:
    boolean }> = {
      '-o': { key: 'output', takesValue: true },
      '--output': { key: 'output', takesValue: true },
      '-p': { key: 'project', takesValue: true },
      '--project': { key: 'project', takesValue: true },
      '-c': { key: 'config', takesValue: true },
      '--config': { key: 'config', takesValue: true },
      '--max-workers': { key: 'maxWorkers', takesValue: true },
      '--watch': { key: 'watch', takesValue: false },
      '-h': { key: 'help', takesValue: false },
      '--help': { key: 'help', takesValue: false },
      '-v': { key: 'version', takesValue: false },
      '--version': { key: 'version', takesValue: false },
    };


    function parseArgs(args: string[]): CliOptions {
      const options: CliOptions = {
        include: [],
        watch: false,
        help: false,
        version: false,
      };
      const cliArgs = args.slice(2);

      for (let i = 0; i < cliArgs.length; i++) {
        const arg = cliArgs[i];
        if (!arg) continue;
        const config = ARG_CONFIG[arg];
        if (config) {
          if (config.takesValue) {
            const value = cliArgs[++i];
            if (config.key === 'maxWorkers') {
              const numValue = parseInt(value, 10);
              if (isNaN(numValue) || numValue < 1) {
                console.error(`Invalid value for --max-workers: ${value}. Must be a positive integer.`);
                process.exit(1);
              }
              (options as any)[config.key] = numValue;
            } else {
              (options as any)[config.key] = value;
            }
          } else {
            (options as any)[config.key] = true;
          }
        } else if (arg.startsWith('-')) {
          console.error(`Unknown option: ${arg}`);
          process.exit(1);
        } else {
          options.include.push(arg);
        }
      }

      return options;
    }


    async function loadConfig(configPath?: string): Promise<Partial<ScnTsConfig>
    & { output?: string }> {
      const path = resolve(process.cwd(), configPath || 'scn.config.js');
      if (existsSync(path)) {
        try {
          if (path.endsWith('.js')) {
            const configModule = await import(path);
            return configModule.default || configModule;
          }
          if (path.endsWith('.json')) {
             return JSON.parse(readFileSync(path, 'utf-8'));
          }
        } catch (e) {
          console.error(`Error loading config file: ${path}`);
          console.error(e);
          process.exit(1);
        }
      }
      return {};
    }


    function showHelp() {
      console.log(`
      scn-ts v${version}
      
      Generates a Symbolic Context Notation map from a TypeScript/JavaScript project.

      Usage:
        scn-ts [globs...] [options]

      Arguments:
        globs...         Glob patterns specifying files to include.

      Options:
        -o, --output <path>      Path to write the SCN output file. (default: stdout)
        -p, --project <path>     Path to tsconfig.json.
        -c, --config <path>      Path to a config file. (default: scn.config.js)
        --max-workers <num>      Number of parallel workers for analysis. (default: 1)
        --watch                  Watch files for changes and re-generate.
        -v, --version            Display version number.
        -h, --help               Display this help message.
      `);
    }


    async function run() {
      const cliOptions = parseArgs(process.argv);

      if (cliOptions.version) {
        console.log(version);
        return;
      }
      
      if (cliOptions.help) {
        showHelp();
        return;
      }

      const fileConfig = await loadConfig(cliOptions.config);

      const config: ScnTsConfig = {
        root: process.cwd(),
        include: cliOptions.include.length > 0 ? cliOptions.include : (fileConfig.include || []),
        exclude: fileConfig.exclude,
        project: cliOptions.project || fileConfig.project,
        maxWorkers: cliOptions.maxWorkers || fileConfig.maxWorkers,
      };
      
      const output = cliOptions.output || fileConfig.output;

      if (config.include.length === 0) {
        console.error('Error: No input files specified. Provide glob patterns as arguments or in a config file.');
        showHelp();
        process.exit(1);
      }

      const executeGeneration = async () => {
        try {
          console.error(`[SCN-TS] Analyzing project...`);
          const scn = await generateScn(config);
          if (output) {
            await writeFile(output, scn, 'utf-8');
            console.error(`[SCN-TS] SCN map written to ${relative(process.cwd(), output)}`);
          } else {
            console.log(scn);
          }
        } catch (e: any) {
          console.error(`[SCN-TS] Error during generation: ${e.message}`);
          if (!cliOptions.watch) {
             process.exit(1);
          }
        }
      };

      await executeGeneration();
      
      if (cliOptions.watch) {
        console.error('[SCN-TS] Watching for file changes...');
        watch(config.root || process.cwd(), { recursive: true }, async (eventType, filename) => {
            if (filename) {
                console.error(`[SCN-TS] Change detected in '${filename}'. Re-generating...`);
                await executeGeneration();
            }
        });
      }
    }


    run().catch(e => {
        console.error(e);
        process.exit(1);
    });
  test/ts/unit/jsx.test.ts: |-
    import { describe, it, expect, afterEach } from 'bun:test';
    import { generateScn } from '../../../src/index';
    import { setupTestProject, type TestProject } from '../../test.util';

    describe('SCN Generation: 1.6 JS/TS Specifics (JSX & Modules)', () => {
      let project: TestProject | undefined;

      afterEach(async () => {
        if (project) {
          await project.cleanup();
          project = undefined;
        }
      });

      it('should correctly parse a React functional component with props with ◇', async () => {
        project = await setupTestProject({
          'Button.tsx': `
            export function Button({ label, onClick }: { label: string, onClick: () => void }) {
              return <button>{label}</button>
            }
          `,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.tsx'], project: 'tsconfig.json' });
        expect(scn).toContain('+ ◇ (1.1) Button { props: { label:#, onClick:# } }');
      });
      
      it('should represent a JSX element with ⛶ and its attributes', async () => {
        project = await setupTestProject({
          'Component.tsx': `
            export function Component() {
              return <div id="main" className="container fluid">Hello</div>;
            }
          `,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.tsx'], project: 'tsconfig.json' });
        const divLine = scn.split('\n').find(line => line.includes('⛶ (1.2) div'));
        expect(divLine).toBeDefined();
        expect(divLine!).toContain('id:#main');
        expect(divLine!).toContain('class:.container .fluid');
      });

      it('should represent JSX hierarchy with indentation', async () => {
        project = await setupTestProject({
          'App.tsx': `
            export function App() {
              return (
                <main>
                  <h1>Title</h1>
                </main>
              );
            }
          `,
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.tsx'], project: 'tsconfig.json' });
        const lines = scn.split('\n');
        const mainIndex = lines.findIndex(l => l.includes('⛶ (1.2) main'));
        const h1Index = lines.findIndex(l => l.includes('⛶ (1.3) h1'));

        expect(mainIndex).toBeGreaterThan(-1);
        expect(h1Index).toBeGreaterThan(-1);
        expect(h1Index).toBe(mainIndex + 1);
        
        const mainIndentation = lines[mainIndex].match(/^\s*/)?.[0].length ?? 0;
        const h1Indentation = lines[h1Index].match(/^\s*/)?.[0].length ?? 0;
        
        expect(h1Indentation).toBeGreaterThan(mainIndentation);
      });

      it('should correctly parse various export syntaxes, including re-exports and aliases', async () => {
        project = await setupTestProject({
          'mod.ts': `
            const internal = 1;
            function b() {}
            export { internal as exported, b };
            export * from './another';
          `,
          'another.ts': 'export const c = 3;',
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        const modScn = scn.split('\n\n').find(s => s.includes('mod.ts'));
        // Files: another.ts (1), mod.ts (2)
        expect(modScn).toContain('§ (2) mod.ts\n  -> (1.0)');
        expect(modScn).toContain('@ (2.1) internal = 1');
        expect(modScn).toContain('~ (2.2) b()');
        // Note: The alias `exported` is not represented as a separate SCN entity.
        // The link is to the original `internal` variable.
      });

      it('should correctly parse various import syntaxes and link them from the consuming function', async () => {
        project = await setupTestProject({
          'util.ts': `
            export const val = 1;
            export function func() {}
            export default class MyClass {}
          `,
          'main.ts': `
            import MyClass, { val } from './util';
            import * as utils from './util';
            
            function run() {
                const x = val;
                utils.func();
                new MyClass();
            }
          `
        });
        const scn = await generateScn({ root: project.projectDir, include: ['**/*.ts'] });
        const mainScn = scn.split('\n\n').find(s => s.includes('main.ts'));
        // Files: main.ts (1), util.ts (2)
        // Entities in util.ts: val (2.1), func (2.2), MyClass (2.3)
        // Entity in main.ts: run (1.1)
        expect(mainScn).toContain('§ (1) main.ts\n  -> (2.0)');
        expect(mainScn).toContain('  ~ (1.1) run()\n    -> (2.1), (2.2), (2.3)');
      });
    });
approved: true
